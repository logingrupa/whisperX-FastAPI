---
phase: 01-websocket-task-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - app/infrastructure/database/models.py
  - app/schemas.py
  - app/infrastructure/websocket/progress_emitter.py
  - app/infrastructure/websocket/__init__.py
  - app/services/whisperx_wrapper_service.py
  - app/api/task_api.py
autonomous: true

must_haves:
  truths:
    - "Progress updates are emitted during transcription, alignment, and diarization stages"
    - "Progress includes percentage (0-100) and current stage name"
    - "Error messages include both user-friendly message and technical details"
    - "Task progress can be retrieved via GET /tasks/{task_id}/progress endpoint"
    - "Polling endpoint returns current state even if WebSocket never connected"
  artifacts:
    - path: "app/infrastructure/database/models.py"
      provides: "Task model with progress_percentage and progress_stage columns"
      contains: "progress_percentage"
    - path: "app/infrastructure/websocket/progress_emitter.py"
      provides: "ProgressEmitter service for emitting progress from sync code"
      exports: ["ProgressEmitter", "progress_emitter"]
    - path: "app/api/task_api.py"
      provides: "GET /tasks/{task_id}/progress endpoint"
      contains: "@task_router.get.*progress"
  key_links:
    - from: "app/services/whisperx_wrapper_service.py"
      to: "app/infrastructure/websocket/progress_emitter.py"
      via: "calls emit_progress between processing stages"
      pattern: "progress_emitter\\.emit_progress"
    - from: "app/api/task_api.py"
      to: "app/infrastructure/database/models.py"
      via: "queries progress_percentage and progress_stage"
      pattern: "progress_percentage|progress_stage"
---

<objective>
Enable progress emission from background tasks and provide fallback polling endpoint.

Purpose: Connect the WebSocket infrastructure (Plan 01) to actual task processing. Background tasks emit progress at each stage, and clients can poll for progress if WebSocket fails.

Output: ProgressEmitter service integrated with `process_audio_common()`, progress persisted to database, and polling endpoint at `GET /tasks/{task_id}/progress`.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-websocket-task-infrastructure/01-RESEARCH.md
@.planning/phases/01-websocket-task-infrastructure/01-01-SUMMARY.md

# Key source files to modify
@app/services/whisperx_wrapper_service.py
@app/infrastructure/database/models.py
@app/schemas.py
@app/api/task_api.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progress fields to database model and schemas</name>
  <files>
app/infrastructure/database/models.py
app/schemas.py
  </files>
  <action>
Extend the Task model and schemas with progress tracking fields.

In `app/infrastructure/database/models.py`:

Add to the Task class (after existing fields):
```python
progress_percentage: Mapped[int | None] = mapped_column(
    Integer, nullable=True, default=0,
    comment="Current progress percentage (0-100)"
)
progress_stage: Mapped[str | None] = mapped_column(
    String, nullable=True,
    comment="Current processing stage (queued, transcribing, aligning, diarizing, complete)"
)
```

In `app/schemas.py`:

1. Add `TaskProgressStage` enum after `TaskStatus`:
```python
class TaskProgressStage(str, Enum):
    """Enum for task progress stages."""
    queued = "queued"
    transcribing = "transcribing"
    aligning = "aligning"
    diarizing = "diarizing"
    complete = "complete"
```

2. Create `TaskProgress` response model (add near other task-related models):
```python
class TaskProgress(BaseModel):
    """Model for task progress information."""
    identifier: str
    status: str
    progress_percentage: int
    progress_stage: str | None
    error: str | None = None
```

Note: The `uploading` stage from CONTEXT.md is handled client-side (frontend tracks upload progress), so backend stages start at `queued`.
  </action>
  <verify>
Run database migration check and import test:
```bash
python -c "
from app.infrastructure.database.models import Task
from app.schemas import TaskProgressStage, TaskProgress
print('Task has progress_percentage:', hasattr(Task, 'progress_percentage'))
print('Task has progress_stage:', hasattr(Task, 'progress_stage'))
print('TaskProgressStage values:', [s.value for s in TaskProgressStage])
print('TaskProgress fields:', TaskProgress.model_fields.keys())
"
```
  </verify>
  <done>Task model has progress_percentage and progress_stage columns, TaskProgressStage enum and TaskProgress schema defined</done>
</task>

<task type="auto">
  <name>Task 2: Create ProgressEmitter service</name>
  <files>
app/infrastructure/websocket/progress_emitter.py
app/infrastructure/websocket/__init__.py
  </files>
  <action>
Create ProgressEmitter service that bridges sync background tasks to async WebSocket connections.

In `app/infrastructure/websocket/progress_emitter.py`:

```python
"""Progress emission service for bridging sync background tasks to WebSocket clients."""

import asyncio
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from app.core.logging import logger
from app.schemas import TaskProgressStage

if TYPE_CHECKING:
    from app.infrastructure.websocket.connection_manager import ConnectionManager


class ProgressEmitter:
    """
    Emits progress updates from synchronous background tasks to WebSocket clients.

    Background tasks run in a thread pool without an event loop.
    This service bridges that gap by creating a temporary event loop for emission.
    """

    def __init__(self, connection_manager: "ConnectionManager") -> None:
        self.manager = connection_manager

    def emit_progress(
        self,
        task_id: str,
        stage: TaskProgressStage,
        percentage: int,
        message: str = "",
    ) -> None:
        """
        Emit progress update from sync code (background tasks run in thread pool).

        Args:
            task_id: The task identifier
            stage: Current processing stage
            percentage: Progress percentage (0-100)
            message: Optional status message
        """
        try:
            loop = asyncio.new_event_loop()
            try:
                loop.run_until_complete(
                    self.manager.send_to_task(task_id, {
                        "type": "progress",
                        "task_id": task_id,
                        "stage": stage.value,
                        "percentage": percentage,
                        "message": message,
                        "timestamp": datetime.now(timezone.utc).isoformat(),
                    })
                )
            finally:
                loop.close()
        except Exception as e:
            # Don't let WebSocket errors crash the background task
            logger.warning(
                "Failed to emit progress for task %s: %s",
                task_id,
                str(e)
            )

    def emit_error(
        self,
        task_id: str,
        error_code: str,
        user_message: str,
        technical_detail: str | None = None,
    ) -> None:
        """
        Emit error message from sync code.

        Args:
            task_id: The task identifier
            error_code: Error code for programmatic handling
            user_message: User-friendly error message
            technical_detail: Optional technical details for debugging
        """
        try:
            loop = asyncio.new_event_loop()
            try:
                loop.run_until_complete(
                    self.manager.send_to_task(task_id, {
                        "type": "error",
                        "task_id": task_id,
                        "error_code": error_code,
                        "user_message": user_message,
                        "technical_detail": technical_detail,
                        "timestamp": datetime.now(timezone.utc).isoformat(),
                    })
                )
            finally:
                loop.close()
        except Exception as e:
            logger.warning(
                "Failed to emit error for task %s: %s",
                task_id,
                str(e)
            )
```

Create module-level singleton (lazy initialization to avoid circular imports):
```python
# Lazy singleton - initialized on first use
_progress_emitter: ProgressEmitter | None = None


def get_progress_emitter() -> ProgressEmitter:
    """Get or create the progress emitter singleton."""
    global _progress_emitter
    if _progress_emitter is None:
        from app.infrastructure.websocket.connection_manager import connection_manager
        _progress_emitter = ProgressEmitter(connection_manager)
    return _progress_emitter
```

Update `app/infrastructure/websocket/__init__.py`:
- Add exports: `ProgressEmitter`, `get_progress_emitter`
  </action>
  <verify>
```bash
python -c "
from app.infrastructure.websocket import get_progress_emitter
emitter = get_progress_emitter()
print('ProgressEmitter type:', type(emitter).__name__)
print('Has emit_progress:', hasattr(emitter, 'emit_progress'))
print('Has emit_error:', hasattr(emitter, 'emit_error'))
"
```
  </verify>
  <done>ProgressEmitter service created with emit_progress and emit_error methods, accessible via get_progress_emitter()</done>
</task>

<task type="auto">
  <name>Task 3a: Add imports and helper function for progress emission</name>
  <files>app/services/whisperx_wrapper_service.py</files>
  <action>
Add imports and helper function for progress emission. This prepares the module for Task 3b.

1. Import get_progress_emitter and TaskProgressStage at top of file (after existing imports):
```python
from app.infrastructure.websocket import get_progress_emitter
from app.schemas import TaskProgressStage
```

2. Add helper function `_update_progress` before `process_audio_common`:
```python
def _update_progress(
    repository: ITaskRepository,
    identifier: str,
    stage: TaskProgressStage,
    percentage: int,
) -> None:
    """Update progress in database and emit to WebSocket clients."""
    # Update database for polling fallback
    repository.update(
        identifier=identifier,
        update_data={
            "progress_stage": stage.value,
            "progress_percentage": percentage,
        },
    )
    # Emit to WebSocket clients
    progress_emitter = get_progress_emitter()
    progress_emitter.emit_progress(identifier, stage, percentage)
```
  </action>
  <verify>
```bash
python -c "
from app.services import whisperx_wrapper_service
assert hasattr(whisperx_wrapper_service, '_update_progress'), '_update_progress helper not found'
assert hasattr(whisperx_wrapper_service, 'get_progress_emitter'), 'get_progress_emitter not imported'
assert hasattr(whisperx_wrapper_service, 'TaskProgressStage'), 'TaskProgressStage not imported'
print('Imports and helper function added successfully')
"
```
  </verify>
  <done>whisperx_wrapper_service has get_progress_emitter import, TaskProgressStage import, and _update_progress helper function</done>
</task>

<task type="auto">
  <name>Task 3b: Integrate progress calls into happy path</name>
  <files>app/services/whisperx_wrapper_service.py</files>
  <action>
Add `_update_progress()` calls at each processing stage in `process_audio_common()`.

Insert these calls at the following points:

1. At start (after repository creation, before any processing):
   `_update_progress(repository, params.identifier, TaskProgressStage.queued, 0)`

2. Before transcription (after logging "Starting speech-to-text processing"):
   `_update_progress(repository, params.identifier, TaskProgressStage.transcribing, 10)`

3. After transcription, before alignment:
   `_update_progress(repository, params.identifier, TaskProgressStage.aligning, 40)`

4. After alignment, before diarization:
   `_update_progress(repository, params.identifier, TaskProgressStage.diarizing, 60)`

5. After diarization, before speaker assignment (in "combining" step):
   `_update_progress(repository, params.identifier, TaskProgressStage.diarizing, 80)`

6. On successful completion (before final repository.update that sets status to "completed"):
   `_update_progress(repository, params.identifier, TaskProgressStage.complete, 100)`

Note: Percentage values are stage-based as per research recommendations (transcription duration varies too much for accurate time-based estimates).
  </action>
  <verify>
```bash
python -c "
import inspect
from app.services import whisperx_wrapper_service

source = inspect.getsource(whisperx_wrapper_service.process_audio_common)

# Check for TaskProgressStage usage in function
stages_found = []
for stage in ['queued', 'transcribing', 'aligning', 'diarizing', 'complete']:
    if f'TaskProgressStage.{stage}' in source:
        stages_found.append(stage)

assert len(stages_found) >= 4, f'Expected at least 4 stages, found: {stages_found}'
assert '_update_progress' in source, '_update_progress not called in process_audio_common'
print(f'Progress calls found for stages: {stages_found}')
"
```
  </verify>
  <done>process_audio_common calls _update_progress at queued, transcribing, aligning, diarizing, and complete stages</done>
</task>

<task type="auto">
  <name>Task 3c: Add progress emission on error paths</name>
  <files>app/services/whisperx_wrapper_service.py</files>
  <action>
Add error emission in exception handlers within `process_audio_common()`.

In each exception handler (catch blocks), add error emission before setting status to "failed":

```python
progress_emitter = get_progress_emitter()
progress_emitter.emit_error(
    params.identifier,
    error_code="PROCESSING_FAILED",
    user_message="Transcription processing failed. Please try again.",
    technical_detail=str(e),
)
```

Apply this pattern to all exception handlers that update task status to "failed".
  </action>
  <verify>
```bash
python -c "
import inspect
from app.services import whisperx_wrapper_service

source = inspect.getsource(whisperx_wrapper_service.process_audio_common)

assert 'emit_error' in source, 'emit_error not called in process_audio_common'
assert 'PROCESSING_FAILED' in source, 'Error code PROCESSING_FAILED not found'
print('Error emission integrated in exception handlers')
"
```
  </verify>
  <done>Exception handlers in process_audio_common emit errors via progress_emitter.emit_error</done>
</task>

<task type="auto">
  <name>Task 4: Create fallback polling endpoint</name>
  <files>app/api/task_api.py</files>
  <action>
Add polling endpoint for clients that can't use WebSockets.

Import at top (if not already present):
```python
from app.schemas import TaskProgress
```

Add new endpoint in `task_api.py` (after existing task endpoints):

```python
@task_router.get(
    "/tasks/{identifier}/progress",
    response_model=TaskProgress,
    tags=["Tasks Management"],
    summary="Get task progress",
    description="Get current progress for a task. Use this as fallback when WebSocket is unavailable.",
)
async def get_task_progress(
    identifier: str,
    repository: ITaskRepository = Depends(get_task_repository),
) -> TaskProgress:
    """
    Get current progress for a task.

    Returns progress percentage, current stage, and status.
    Use this endpoint as fallback when WebSocket connection fails.

    Args:
        identifier: The task identifier (UUID)
        repository: Task repository (injected)

    Returns:
        TaskProgress with current progress information

    Raises:
        TaskNotFoundError: If task with identifier doesn't exist
    """
    task = repository.get_by_id(identifier)
    if task is None:
        raise TaskNotFoundError(identifier=identifier)

    return TaskProgress(
        identifier=task.uuid,
        status=task.status,
        progress_percentage=task.progress_percentage or 0,
        progress_stage=task.progress_stage,
        error=task.error,
    )
```

Note: This endpoint uses `session.refresh(task)` implicitly through the repository pattern. If stale data is observed (research pitfall #4), the repository's `get_by_id` should be modified to use a fresh session.
  </action>
  <verify>
```bash
# Start server and test endpoint
uvicorn app.main:app --reload &
sleep 3

curl -s http://localhost:8000/tasks/nonexistent-id/progress | head -20
# Should return 404 with TaskNotFoundError

# Check endpoint exists in OpenAPI
curl -s http://localhost:8000/openapi.json | python -c "
import json, sys
spec = json.load(sys.stdin)
paths = spec.get('paths', {})
progress_path = paths.get('/tasks/{identifier}/progress')
if progress_path and 'get' in progress_path:
    print('Progress endpoint found in OpenAPI spec')
else:
    print('ERROR: Progress endpoint not found')
    sys.exit(1)
"
```
  </verify>
  <done>GET /tasks/{identifier}/progress endpoint returns TaskProgress with percentage, stage, status, and error</done>
</task>

</tasks>

<verification>
1. Database migration applies cleanly (progress_percentage, progress_stage columns added)
2. Progress updates are emitted during background processing (check logs)
3. Polling endpoint returns current progress for existing tasks
4. Polling endpoint returns 404 for non-existent tasks
5. Error messages include both user-friendly message and technical details
6. WebSocket clients receive progress updates during processing (if connected)
7. Type checking passes: `mypy app/services/whisperx_wrapper_service.py app/api/task_api.py`
</verification>

<success_criteria>
- Database has progress_percentage and progress_stage columns on tasks table
- `GET /tasks/{task_id}/progress` returns valid TaskProgress response
- Background processing emits progress at each stage (verify via WebSocket or logs)
- Error handling includes progress_emitter.emit_error calls
- All existing tests pass
- Type checking passes for modified files
</success_criteria>

<output>
After completion, create `.planning/phases/01-websocket-task-infrastructure/01-02-SUMMARY.md`
</output>
