---
phase: 01-websocket-task-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/infrastructure/websocket/__init__.py
  - app/infrastructure/websocket/connection_manager.py
  - app/schemas/websocket_schemas.py
  - app/api/websocket_api.py
  - app/main.py
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint accepts connections at /ws/tasks/{task_id}"
    - "Connected clients receive heartbeat messages every 30 seconds"
    - "ConnectionManager maintains Dict[str, list[WebSocket]] structure for multi-client support"
    - "Disconnected clients are cleaned up from connection tracking"
  artifacts:
    - path: "app/infrastructure/websocket/connection_manager.py"
      provides: "ConnectionManager class with task-keyed connections"
      exports: ["ConnectionManager"]
    - path: "app/schemas/websocket_schemas.py"
      provides: "Pydantic schemas for WebSocket messages"
      exports: ["ProgressStage", "ProgressMessage", "ErrorMessage", "HeartbeatMessage"]
    - path: "app/api/websocket_api.py"
      provides: "WebSocket endpoint handler"
      exports: ["websocket_router"]
  key_links:
    - from: "app/api/websocket_api.py"
      to: "app/infrastructure/websocket/connection_manager.py"
      via: "imports ConnectionManager singleton"
      pattern: "from app.infrastructure.websocket import connection_manager"
    - from: "app/main.py"
      to: "app/api/websocket_api.py"
      via: "router registration"
      pattern: "app.include_router.*websocket_router"
---

<objective>
Create WebSocket infrastructure for real-time task progress updates.

Purpose: Enable the backend to push progress updates to connected clients during long-running transcription operations (5-30 minutes). This is the foundation for Phase 5's progress UI.

Output: WebSocket endpoint at `/ws/tasks/{task_id}` with ConnectionManager for task-keyed connections and 30-second heartbeat to prevent proxy timeouts.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-websocket-task-infrastructure/01-RESEARCH.md

# Existing codebase patterns
@app/main.py
@app/schemas.py
@app/api/__init__.py
@app/infrastructure/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket message schemas</name>
  <files>app/schemas/websocket_schemas.py</files>
  <action>
Create Pydantic schemas for WebSocket messages following existing schema patterns in `app/schemas.py`.

Create `app/schemas/` directory if it doesn't exist (currently schemas are in `app/schemas.py` root file).

Define:
1. `ProgressStage` enum with values: uploading, queued, transcribing, aligning, diarizing, complete
2. `ProgressMessage` model with fields: type="progress", task_id, stage (ProgressStage), percentage (int 0-100), message (optional str), timestamp (datetime)
3. `ErrorMessage` model with fields: type="error", task_id, error_code (str), user_message (str), technical_detail (optional str), timestamp (datetime)
4. `HeartbeatMessage` model with fields: type="heartbeat", timestamp (datetime)

Follow existing conventions:
- Use `str` Enum pattern like `TaskStatus` in existing schemas
- Use `datetime` for timestamps (not float)
- Include docstrings for all classes
  </action>
  <verify>
Run: `python -c "from app.schemas.websocket_schemas import ProgressStage, ProgressMessage, ErrorMessage, HeartbeatMessage; print('Import successful')"`
  </verify>
  <done>All four WebSocket message schemas importable and validated by Pydantic</done>
</task>

<task type="auto">
  <name>Task 2: Create ConnectionManager with heartbeat support</name>
  <files>
app/infrastructure/websocket/__init__.py
app/infrastructure/websocket/connection_manager.py
  </files>
  <action>
Create the websocket infrastructure module following DDD patterns.

In `app/infrastructure/websocket/connection_manager.py`:

1. Create `ConnectionManager` class:
   - `__init__`: Initialize `active_connections: Dict[str, list[WebSocket]]` and `asyncio.Lock`
   - `async connect(task_id: str, websocket: WebSocket)`: Accept connection, add to task's connection list
   - `async disconnect(task_id: str, websocket: WebSocket)`: Remove from list, cleanup empty task entries
   - `async send_to_task(task_id: str, message: dict)`: Send JSON to all connections watching a task
   - `async send_heartbeat(task_id: str)`: Send heartbeat message to all connections for a task
   - `get_connection_count(task_id: str) -> int`: Return number of active connections for a task

2. Use `asyncio.Lock` for thread-safe connection list access (research pitfall #1)

3. Handle exceptions in `send_to_task` gracefully - don't crash if one connection fails

4. Create module singleton: `connection_manager = ConnectionManager()`

In `app/infrastructure/websocket/__init__.py`:
- Export `ConnectionManager` and `connection_manager` singleton

Update `app/infrastructure/__init__.py` to include websocket module in exports.
  </action>
  <verify>
Run: `python -c "from app.infrastructure.websocket import ConnectionManager, connection_manager; print('ConnectionManager imported:', type(connection_manager))"`
  </verify>
  <done>ConnectionManager class exists with connect, disconnect, send_to_task, send_heartbeat methods and module-level singleton</done>
</task>

<task type="auto">
  <name>Task 3: Create WebSocket endpoint with heartbeat loop</name>
  <files>
app/api/websocket_api.py
app/api/__init__.py
app/main.py
  </files>
  <action>
Create WebSocket endpoint following existing API patterns.

In `app/api/websocket_api.py`:

1. Create `websocket_router = APIRouter()` (no prefix - WebSocket routes are registered directly)

2. Create endpoint `@websocket_router.websocket("/ws/tasks/{task_id}")`:
   - Accept `websocket: WebSocket` and `task_id: str` parameters
   - Call `connection_manager.connect(task_id, websocket)`
   - Start heartbeat task using `asyncio.create_task()`:
     - Loop: `await asyncio.sleep(30)`, then send heartbeat via `connection_manager.send_heartbeat(task_id)`
     - Catch exceptions to break loop on connection close
   - Main loop: `await websocket.receive_json()` to keep connection alive
     - Handle client ping messages: if `data.get("type") == "ping"`, respond with `{"type": "pong"}`
   - On `WebSocketDisconnect`: cancel heartbeat task, call `connection_manager.disconnect()`
   - Use try/finally to ensure cleanup

3. Import HeartbeatMessage from websocket_schemas for heartbeat messages

In `app/api/__init__.py`:
- Import and export `websocket_router`

In `app/main.py`:
- Import `websocket_router` from `app.api`
- Add `app.include_router(websocket_router)` after existing router registrations
  </action>
  <verify>
Verify WebSocket endpoint is registered in OpenAPI spec and router includes the endpoint:
```bash
# Check that WebSocket endpoint is registered in the app
python -c "
from app.main import app

# Check routes for WebSocket endpoint
ws_routes = [r for r in app.routes if hasattr(r, 'path') and '/ws/tasks/' in r.path]
assert len(ws_routes) > 0, 'WebSocket route not found in app'
print('WebSocket route registered:', ws_routes[0].path)

# Verify websocket_router is imported and included
from app.api import websocket_router
assert websocket_router is not None, 'websocket_router not exported from app.api'
print('websocket_router exported successfully')

# Check ConnectionManager is available
from app.infrastructure.websocket import connection_manager
assert hasattr(connection_manager, 'connect'), 'ConnectionManager missing connect method'
assert hasattr(connection_manager, 'send_heartbeat'), 'ConnectionManager missing send_heartbeat method'
print('ConnectionManager has required methods')
"
```
  </verify>
  <done>WebSocket endpoint at /ws/tasks/{task_id} accepts connections and sends heartbeats every 30 seconds</done>
</task>

</tasks>

<verification>
1. WebSocket endpoint responds to connections at `/ws/tasks/{task_id}`
2. Connected clients receive heartbeat messages every 30 seconds
3. Multiple clients can connect to watch the same task
4. Client disconnection properly cleans up connection tracking
5. All imports resolve without circular dependency errors
6. Existing API endpoints still work (no regressions)
</verification>

<success_criteria>
- WebSocket connection established successfully
- Heartbeat received within 35 seconds of connection
- Clean disconnection handling (no errors in logs)
- `python -m pytest tests/` passes (if tests exist)
- Type checking passes: `mypy app/infrastructure/websocket/ app/api/websocket_api.py app/schemas/websocket_schemas.py`
</success_criteria>

<output>
After completion, create `.planning/phases/01-websocket-task-infrastructure/01-01-SUMMARY.md`
</output>
