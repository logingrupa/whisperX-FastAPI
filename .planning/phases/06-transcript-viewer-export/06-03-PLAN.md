---
phase: 06-transcript-viewer-export
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - frontend/src/components/transcript/TranscriptSegmentRow.tsx
  - frontend/src/components/transcript/TranscriptViewer.tsx
  - frontend/src/components/transcript/DownloadButtons.tsx
autonomous: true

must_haves:
  truths:
    - "User can see transcript segments with timestamps"
    - "User can see speaker labels for each segment"
    - "User can download transcript in SRT format"
    - "User can download transcript in VTT format"
    - "User can download transcript in TXT format"
    - "User can download transcript in JSON format"
  artifacts:
    - path: "frontend/src/components/transcript/TranscriptSegmentRow.tsx"
      provides: "Single segment display"
      exports: ["TranscriptSegmentRow"]
    - path: "frontend/src/components/transcript/TranscriptViewer.tsx"
      provides: "Full transcript display with scroll"
      exports: ["TranscriptViewer"]
    - path: "frontend/src/components/transcript/DownloadButtons.tsx"
      provides: "Download format buttons"
      exports: ["DownloadButtons"]
  key_links:
    - from: "frontend/src/components/transcript/TranscriptViewer.tsx"
      to: "frontend/src/components/transcript/TranscriptSegmentRow.tsx"
      via: "segment mapping"
      pattern: "TranscriptSegmentRow"
    - from: "frontend/src/components/transcript/DownloadButtons.tsx"
      to: "frontend/src/hooks/useTranscriptDownload.ts"
      via: "download hook usage"
      pattern: "useTranscriptDownload"
---

<objective>
Create transcript viewer UI components

Purpose: Build the visual components for displaying transcripts with timestamps, speaker labels, and download buttons

Output: TranscriptSegmentRow, TranscriptViewer, and DownloadButtons components ready for integration
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-transcript-viewer-export/06-RESEARCH.md
@.planning/phases/06-transcript-viewer-export/06-01-SUMMARY.md
@.planning/phases/06-transcript-viewer-export/06-02-SUMMARY.md

# Existing component patterns
@frontend/src/components/upload/FileQueueItem.tsx
@frontend/src/components/ui/scroll-area.tsx
@frontend/src/components/ui/button.tsx
@frontend/src/components/ui/badge.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TranscriptSegmentRow component</name>
  <files>frontend/src/components/transcript/TranscriptSegmentRow.tsx</files>
  <action>
Create `frontend/src/components/transcript/` directory and `TranscriptSegmentRow.tsx`:

```typescript
import { Badge } from '@/components/ui/badge';
import type { TranscriptSegment } from '@/types/transcript';

interface TranscriptSegmentRowProps {
  segment: TranscriptSegment;
  index: number;
}

/**
 * Format seconds to MM:SS or HH:MM:SS for display
 */
function formatTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
  }
  return `${minutes}:${String(secs).padStart(2, '0')}`;
}

/**
 * Format speaker label for display
 * Converts "SPEAKER_00" to "Speaker 1", "SPEAKER_01" to "Speaker 2", etc.
 */
function formatSpeakerLabel(speaker: string | null): string | null {
  if (!speaker) return null;

  // Handle "SPEAKER_XX" format from diarization
  const match = speaker.match(/SPEAKER_(\d+)/i);
  if (match) {
    const speakerNumber = parseInt(match[1], 10) + 1;
    return `Speaker ${speakerNumber}`;
  }

  // Return as-is if different format
  return speaker;
}

/**
 * Single transcript segment with timestamp and speaker label
 */
export function TranscriptSegmentRow({ segment, index }: TranscriptSegmentRowProps) {
  const speakerLabel = formatSpeakerLabel(segment.speaker);

  return (
    <div className="flex gap-3 py-2 border-b border-border last:border-b-0">
      {/* Timestamp */}
      <div className="shrink-0 w-20 text-xs text-muted-foreground font-mono">
        {formatTimestamp(segment.start)}
      </div>

      {/* Speaker badge (if present) */}
      <div className="shrink-0 w-24">
        {speakerLabel && (
          <Badge variant="outline" className="text-xs">
            {speakerLabel}
          </Badge>
        )}
      </div>

      {/* Text content */}
      <div className="flex-1 text-sm">
        {segment.text}
      </div>
    </div>
  );
}
```

The component:
- Formats timestamps in human-readable format (MM:SS or HH:MM:SS)
- Converts SPEAKER_XX to "Speaker N" for better readability per VIEW-02
- Uses consistent layout with fixed-width timestamp and speaker columns
  </action>
  <verify>TypeScript compiles: `cd frontend && bunx tsc --noEmit`</verify>
  <done>TranscriptSegmentRow displays timestamps, speaker labels, and text</done>
</task>

<task type="auto">
  <name>Task 2: Create TranscriptViewer component</name>
  <files>frontend/src/components/transcript/TranscriptViewer.tsx</files>
  <action>
Create `frontend/src/components/transcript/TranscriptViewer.tsx`:

```typescript
import { ScrollArea } from '@/components/ui/scroll-area';
import { TranscriptSegmentRow } from './TranscriptSegmentRow';
import type { TranscriptSegment } from '@/types/transcript';

interface TranscriptViewerProps {
  segments: TranscriptSegment[];
  maxHeight?: string; // Default: "300px"
}

/**
 * Scrollable transcript viewer with segments
 *
 * Displays all transcript segments in a scrollable container.
 * Uses shadcn/ui ScrollArea for consistent styling.
 */
export function TranscriptViewer({
  segments,
  maxHeight = "300px"
}: TranscriptViewerProps) {
  if (segments.length === 0) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        No transcript segments available
      </div>
    );
  }

  return (
    <ScrollArea className="rounded-md border" style={{ maxHeight }}>
      <div className="p-4">
        {/* Header row */}
        <div className="flex gap-3 pb-2 border-b border-border text-xs font-medium text-muted-foreground">
          <div className="shrink-0 w-20">Time</div>
          <div className="shrink-0 w-24">Speaker</div>
          <div className="flex-1">Text</div>
        </div>

        {/* Segment rows */}
        {segments.map((segment, index) => (
          <TranscriptSegmentRow
            key={`${segment.start}-${index}`}
            segment={segment}
            index={index}
          />
        ))}
      </div>
    </ScrollArea>
  );
}
```

The component:
- Uses ScrollArea for scrollable content (shadcn/ui, already installed)
- Includes header row explaining columns
- Maps segments with unique keys based on start time + index
- Configurable max height (default 300px)
  </action>
  <verify>TypeScript compiles: `cd frontend && bunx tsc --noEmit`</verify>
  <done>TranscriptViewer shows scrollable list of segments with header</done>
</task>

<task type="auto">
  <name>Task 3: Create DownloadButtons component</name>
  <files>frontend/src/components/transcript/DownloadButtons.tsx</files>
  <action>
Create `frontend/src/components/transcript/DownloadButtons.tsx`:

```typescript
import { Download } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useTranscriptDownload } from '@/hooks/useTranscriptDownload';
import type { TranscriptSegment, TaskMetadata } from '@/types/transcript';

interface DownloadButtonsProps {
  segments: TranscriptSegment[];
  filename: string; // Base filename without extension
  metadata?: TaskMetadata;
}

/**
 * Download format buttons for transcript export
 *
 * Provides buttons for downloading transcript in SRT, VTT, TXT, and JSON formats.
 * Uses useTranscriptDownload hook for blob generation and download.
 */
export function DownloadButtons({
  segments,
  filename,
  metadata
}: DownloadButtonsProps) {
  const { downloadTranscript } = useTranscriptDownload();

  const handleDownload = (format: 'srt' | 'vtt' | 'txt' | 'json') => {
    downloadTranscript({
      segments,
      filename,
      format,
      metadata,
    });
  };

  return (
    <div className="flex flex-wrap gap-2">
      <Button
        variant="outline"
        size="sm"
        onClick={() => handleDownload('srt')}
        className="gap-1"
      >
        <Download className="h-3 w-3" />
        SRT
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => handleDownload('vtt')}
        className="gap-1"
      >
        <Download className="h-3 w-3" />
        VTT
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => handleDownload('txt')}
        className="gap-1"
      >
        <Download className="h-3 w-3" />
        TXT
      </Button>

      <Button
        variant="outline"
        size="sm"
        onClick={() => handleDownload('json')}
        className="gap-1"
      >
        <Download className="h-3 w-3" />
        JSON
      </Button>
    </div>
  );
}
```

The component:
- Uses existing Button and Download icon from lucide-react
- Compact button layout with consistent sizing
- Passes metadata to JSON formatter for full export
- Each button triggers download immediately on click
  </action>
  <verify>TypeScript compiles: `cd frontend && bunx tsc --noEmit`</verify>
  <done>DownloadButtons provides SRT, VTT, TXT, JSON download options</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cd frontend && bunx tsc --noEmit` - TypeScript compiles without errors
2. `cd frontend && bun run build` - Build succeeds
3. All three components are importable from their paths
</verification>

<success_criteria>
- TranscriptSegmentRow shows timestamp, speaker label (Speaker 1, 2, etc.), and text
- TranscriptViewer displays scrollable list with header
- DownloadButtons triggers downloads for all four formats
- Components follow existing shadcn/ui patterns in codebase
- Components use existing utility imports (@/lib/utils, @/components/ui/*)
</success_criteria>

<output>
After completion, create `.planning/phases/06-transcript-viewer-export/06-03-SUMMARY.md`
</output>
