---
phase: 06-transcript-viewer-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/types/transcript.ts
  - frontend/src/lib/formatters/srtFormatter.ts
  - frontend/src/lib/formatters/vttFormatter.ts
  - frontend/src/lib/formatters/txtFormatter.ts
  - frontend/src/lib/formatters/jsonFormatter.ts
  - frontend/src/lib/formatters/index.ts
  - frontend/src/hooks/useTranscriptDownload.ts
autonomous: true

must_haves:
  truths:
    - "Transcript segments have typed start, end, text, and speaker fields"
    - "SRT output has correct timestamp format (HH:MM:SS,mmm)"
    - "VTT output has WEBVTT header and correct timestamp format (HH:MM:SS.mmm)"
    - "TXT output contains plain text with optional speaker prefixes"
    - "JSON output preserves all segment metadata"
    - "Download hook creates downloadable blob files"
  artifacts:
    - path: "frontend/src/types/transcript.ts"
      provides: "TranscriptSegment, TaskResult types"
      exports: ["TranscriptSegment", "TaskResult", "TaskMetadata"]
    - path: "frontend/src/lib/formatters/srtFormatter.ts"
      provides: "SRT format generation"
      exports: ["formatTranscriptAsSrt"]
    - path: "frontend/src/lib/formatters/vttFormatter.ts"
      provides: "VTT format generation"
      exports: ["formatTranscriptAsVtt"]
    - path: "frontend/src/lib/formatters/txtFormatter.ts"
      provides: "Plain text format generation"
      exports: ["formatTranscriptAsTxt"]
    - path: "frontend/src/lib/formatters/jsonFormatter.ts"
      provides: "JSON format generation"
      exports: ["formatTranscriptAsJson"]
    - path: "frontend/src/lib/formatters/index.ts"
      provides: "Unified formatter exports"
      exports: ["formatTranscriptAsSrt", "formatTranscriptAsVtt", "formatTranscriptAsTxt", "formatTranscriptAsJson"]
    - path: "frontend/src/hooks/useTranscriptDownload.ts"
      provides: "Blob download functionality"
      exports: ["useTranscriptDownload"]
  key_links:
    - from: "frontend/src/lib/formatters/*.ts"
      to: "frontend/src/types/transcript.ts"
      via: "TranscriptSegment import"
      pattern: "import.*TranscriptSegment.*from.*types/transcript"
    - from: "frontend/src/hooks/useTranscriptDownload.ts"
      to: "frontend/src/lib/formatters/index.ts"
      via: "formatter imports"
      pattern: "import.*from.*formatters"
---

<objective>
Create transcript types and format utilities for transcript export

Purpose: Establish the foundation for transcript viewing and export by defining types and creating pure formatter functions for SRT, VTT, TXT, and JSON formats

Output: Types, formatter utilities, and download hook that later components will use
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-transcript-viewer-export/06-RESEARCH.md

# Existing types for reference
@frontend/src/types/upload.ts
@frontend/src/types/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transcript types</name>
  <files>frontend/src/types/transcript.ts</files>
  <action>
Create `frontend/src/types/transcript.ts` with:

1. `TranscriptSegment` interface:
   - `start: number` (seconds, e.g., 1.5)
   - `end: number` (seconds)
   - `text: string`
   - `speaker: string | null` (e.g., "SPEAKER_00", "SPEAKER_01")

2. `TaskMetadata` interface matching backend `app/api/schemas/task_schemas.py`:
   - `file_name: string | null`
   - `language: string | null`
   - `audio_duration: number | null`

3. `TaskResult` interface for GET /task/{identifier} response:
   - `identifier: string`
   - `status: string`
   - `task_type: string`
   - `file_name: string | null`
   - `url: string | null`
   - `audio_duration: number | null`
   - `language: string | null`
   - `task_params: Record<string, unknown> | null`
   - `result: { segments: TranscriptSegment[] } | null`
   - `error: string | null`
   - `duration: number | null`
   - `start_time: string | null`
   - `end_time: string | null`
   - `created_at: string`
   - `updated_at: string`

Export all types. Add JSDoc comments explaining each type's purpose.
  </action>
  <verify>TypeScript compiles: `cd frontend && bunx tsc --noEmit`</verify>
  <done>Transcript types defined matching backend schema</done>
</task>

<task type="auto">
  <name>Task 2: Create format utilities</name>
  <files>
    frontend/src/lib/formatters/srtFormatter.ts
    frontend/src/lib/formatters/vttFormatter.ts
    frontend/src/lib/formatters/txtFormatter.ts
    frontend/src/lib/formatters/jsonFormatter.ts
    frontend/src/lib/formatters/index.ts
  </files>
  <action>
Create `frontend/src/lib/formatters/` directory and formatter files:

**srtFormatter.ts:**
- `formatSrtTimestamp(seconds: number): string` - Returns "HH:MM:SS,mmm" format
  - Uses comma for milliseconds separator (SRT spec)
  - Zero-pads all components: hours (2), minutes (2), seconds (2), milliseconds (3)
- `formatTranscriptAsSrt(segments: TranscriptSegment[]): string`
  - Each entry: index, timestamp line, text with optional speaker prefix
  - Format: `1\n00:00:01,500 --> 00:00:03,200\n[SPEAKER_00] Hello world\n\n`
  - Double newline between entries

**vttFormatter.ts:**
- `formatVttTimestamp(seconds: number): string` - Returns "HH:MM:SS.mmm" format
  - Uses period for milliseconds separator (VTT spec)
- `formatTranscriptAsVtt(segments: TranscriptSegment[]): string`
  - Starts with "WEBVTT\n\n" header (REQUIRED - without this, VTT files won't parse)
  - Uses VTT voice tags for speakers: `<v SPEAKER_00>text</v>` (not brackets like SRT)
  - Format: `00:00:01.500 --> 00:00:03.200\n<v SPEAKER_00>Hello world\n\n`

**txtFormatter.ts:**
- `formatTranscriptAsTxt(segments: TranscriptSegment[], includeTimestamps?: boolean): string`
  - Default: no timestamps, just speaker and text
  - Format with speakers: `[SPEAKER_00]: Hello world\n`
  - Format without speakers: `Hello world\n`
  - Single newline between segments

**jsonFormatter.ts:**
- `formatTranscriptAsJson(segments: TranscriptSegment[], metadata?: TaskMetadata): string`
  - Returns JSON.stringify with 2-space indentation
  - Structure: `{ metadata?: {...}, segments: [...] }`
  - Preserves all segment fields

**index.ts:**
- Re-export all formatters: `export { formatTranscriptAsSrt } from './srtFormatter'` etc.

CRITICAL PITFALLS TO AVOID (from research):
- SRT uses comma (,) for ms, VTT uses period (.)
- VTT MUST have "WEBVTT" header
- All formatters must handle null speaker gracefully (omit prefix)
  </action>
  <verify>TypeScript compiles: `cd frontend && bunx tsc --noEmit`</verify>
  <done>All four format utilities created with correct specifications</done>
</task>

<task type="auto">
  <name>Task 3: Create download hook</name>
  <files>frontend/src/hooks/useTranscriptDownload.ts</files>
  <action>
Create `frontend/src/hooks/useTranscriptDownload.ts`:

```typescript
import { useCallback } from 'react';
import type { TranscriptSegment, TaskMetadata } from '@/types/transcript';
import {
  formatTranscriptAsSrt,
  formatTranscriptAsVtt,
  formatTranscriptAsTxt,
  formatTranscriptAsJson,
} from '@/lib/formatters';

type ExportFormat = 'srt' | 'vtt' | 'txt' | 'json';

interface DownloadOptions {
  segments: TranscriptSegment[];
  filename: string; // Base filename without extension
  format: ExportFormat;
  metadata?: TaskMetadata; // Only used for JSON format
}

export function useTranscriptDownload() {
  const downloadTranscript = useCallback((options: DownloadOptions) => {
    const { segments, filename, format, metadata } = options;

    // Generate content based on format
    let content: string;
    let mimeType: string;
    let extension: string;

    switch (format) {
      case 'srt':
        content = formatTranscriptAsSrt(segments);
        mimeType = 'text/plain';
        extension = 'srt';
        break;
      case 'vtt':
        content = formatTranscriptAsVtt(segments);
        mimeType = 'text/vtt';
        extension = 'vtt';
        break;
      case 'txt':
        content = formatTranscriptAsTxt(segments);
        mimeType = 'text/plain';
        extension = 'txt';
        break;
      case 'json':
        content = formatTranscriptAsJson(segments, metadata);
        mimeType = 'application/json';
        extension = 'json';
        break;
    }

    // Create blob with UTF-8 encoding (CRITICAL for Latvian/Russian characters)
    const blob = new Blob([content], { type: `${mimeType}; charset=utf-8` });
    const url = URL.createObjectURL(blob);

    // Create and trigger download
    const link = document.createElement('a');
    link.href = url;
    link.download = `${filename}.${extension}`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // CRITICAL: Revoke blob URL to prevent memory leak
    URL.revokeObjectURL(url);
  }, []);

  return { downloadTranscript };
}
```

Export the hook and the ExportFormat type.
  </action>
  <verify>TypeScript compiles: `cd frontend && bunx tsc --noEmit`</verify>
  <done>Download hook can generate and trigger downloads for all formats</done>
</task>

</tasks>

<verification>
After all tasks:
1. `cd frontend && bunx tsc --noEmit` - TypeScript compiles without errors
2. `cd frontend && bun run build` - Build succeeds
3. All exports are accessible from their index files
</verification>

<success_criteria>
- TranscriptSegment type matches backend Segment schema (start, end, text, speaker)
- TaskResult type matches GET /task/{identifier} response
- SRT formatter uses comma separator and sequential indices
- VTT formatter includes WEBVTT header and uses period separator
- TXT formatter produces clean readable text
- JSON formatter preserves all data with proper formatting
- Download hook creates blobs with UTF-8 encoding
- Download hook revokes blob URLs after download
</success_criteria>

<output>
After completion, create `.planning/phases/06-transcript-viewer-export/06-01-SUMMARY.md`
</output>
