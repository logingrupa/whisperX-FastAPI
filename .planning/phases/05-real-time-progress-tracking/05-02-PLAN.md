---
phase: 05-real-time-progress-tracking
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/hooks/useTaskProgress.ts
  - frontend/src/hooks/useFileQueue.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket connects to /ws/tasks/{taskId} endpoint"
    - "Reconnection uses exponential backoff up to 5 attempts"
    - "Progress state syncs on reconnect via polling endpoint"
    - "Heartbeat messages are filtered out (not processed as progress)"
    - "File queue tracks progress percentage and stage per file"
  artifacts:
    - path: "frontend/src/hooks/useTaskProgress.ts"
      provides: "WebSocket hook with reconnection logic"
      exports: ["useTaskProgress"]
    - path: "frontend/src/hooks/useFileQueue.ts"
      provides: "Extended queue hook with progress tracking"
      exports: ["useFileQueue"]
  key_links:
    - from: "frontend/src/hooks/useTaskProgress.ts"
      to: "/ws/tasks/{taskId}"
      via: "react-use-websocket connection"
      pattern: "useWebSocket.*ws/tasks"
    - from: "frontend/src/hooks/useTaskProgress.ts"
      to: "/tasks/{taskId}/progress"
      via: "Polling fallback on reconnect"
      pattern: "fetch.*tasks.*progress"
---

<objective>
Create WebSocket hook for progress tracking and extend file queue with progress state

Purpose: Enable real-time progress updates from backend and state management in frontend
Output: useTaskProgress hook with reconnection, extended useFileQueue with progress tracking
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-real-time-progress-tracking/05-CONTEXT.md
@.planning/phases/05-real-time-progress-tracking/05-RESEARCH.md
@.planning/phases/05-real-time-progress-tracking/05-01-SUMMARY.md

# Existing hooks and types
@frontend/src/hooks/useFileQueue.ts
@frontend/src/types/upload.ts
@frontend/src/types/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTaskProgress hook with WebSocket and reconnection</name>
  <files>frontend/src/hooks/useTaskProgress.ts</files>
  <action>
    Create `frontend/src/hooks/useTaskProgress.ts`:

    ```typescript
    import { useCallback, useEffect, useRef, useState } from 'react';
    import useWebSocket, { ReadyState } from 'react-use-websocket';
    import type { ProgressStage, WebSocketMessage, ProgressMessage, ErrorMessage } from '@/types/websocket';

    /** Maximum reconnection attempts before giving up */
    const MAX_RECONNECT_ATTEMPTS = 5;

    /** Connection state for UI display */
    export interface ConnectionState {
      isConnected: boolean;
      isConnecting: boolean;
      isReconnecting: boolean;
      reconnectAttempt: number;
      maxAttemptsReached: boolean;
    }

    /** Progress state from WebSocket */
    export interface TaskProgressState {
      percentage: number;
      stage: ProgressStage;
      message: string | null;
    }

    /** Error state from WebSocket */
    export interface TaskErrorState {
      errorCode: string;
      userMessage: string;
      technicalDetail: string | null;
    }

    interface UseTaskProgressOptions {
      /** Task ID to subscribe to */
      taskId: string | null;
      /** Called on progress update */
      onProgress?: (taskId: string, progress: TaskProgressState) => void;
      /** Called on error */
      onError?: (taskId: string, error: TaskErrorState) => void;
      /** Called when task completes */
      onComplete?: (taskId: string) => void;
    }

    /**
     * Hook for tracking task progress via WebSocket
     *
     * Features:
     * - Connects to /ws/tasks/{taskId} when taskId is provided
     * - Reconnects with exponential backoff (up to 5 attempts)
     * - Fetches current state on reconnect via polling endpoint
     * - Filters heartbeat messages
     * - Provides connection state for UI display
     */
    export function useTaskProgress({
      taskId,
      onProgress,
      onError,
      onComplete,
    }: UseTaskProgressOptions) {
      const [connectionState, setConnectionState] = useState<ConnectionState>({
        isConnected: false,
        isConnecting: false,
        isReconnecting: false,
        reconnectAttempt: 0,
        maxAttemptsReached: false,
      });

      // Track if we were previously connected (for reconnection detection)
      const wasConnectedRef = useRef(false);
      const reconnectAttemptRef = useRef(0);

      // Build WebSocket URL - null disables connection
      const socketUrl = taskId ? `/ws/tasks/${taskId}` : null;

      // Use refs for callbacks to avoid stale closure issues
      const onProgressRef = useRef(onProgress);
      const onErrorRef = useRef(onError);
      const onCompleteRef = useRef(onComplete);

      useEffect(() => {
        onProgressRef.current = onProgress;
        onErrorRef.current = onError;
        onCompleteRef.current = onComplete;
      }, [onProgress, onError, onComplete]);

      /**
       * Fetch current progress state from polling endpoint
       * Used to sync state on reconnect (get missed updates)
       */
      const syncProgressFromPolling = useCallback(async (taskIdToSync: string) => {
        try {
          const response = await fetch(`/tasks/${taskIdToSync}/progress`);
          if (response.ok) {
            const data = await response.json();
            if (data.stage && data.percentage !== undefined) {
              onProgressRef.current?.(taskIdToSync, {
                percentage: data.percentage,
                stage: data.stage,
                message: data.message || null,
              });
              if (data.stage === 'complete') {
                onCompleteRef.current?.(taskIdToSync);
              }
            }
          }
        } catch (error) {
          console.error('Failed to sync progress from polling endpoint:', error);
        }
      }, []);

      const { readyState, getWebSocket } = useWebSocket(
        socketUrl,
        {
          shouldReconnect: (closeEvent) => {
            // Don't reconnect on normal closure (code 1000) or if task is complete
            if (closeEvent.code === 1000) return false;
            // Don't reconnect if max attempts reached
            if (reconnectAttemptRef.current >= MAX_RECONNECT_ATTEMPTS) return false;
            reconnectAttemptRef.current += 1;
            return true;
          },
          reconnectAttempts: MAX_RECONNECT_ATTEMPTS,
          reconnectInterval: (attemptNumber) => {
            // Exponential backoff: 1s, 2s, 4s, 8s, 16s (capped at 30s)
            return Math.min(1000 * Math.pow(2, attemptNumber), 30000);
          },
          onOpen: () => {
            const wasReconnecting = wasConnectedRef.current;
            wasConnectedRef.current = true;
            reconnectAttemptRef.current = 0;

            // On reconnect, fetch current state to sync missed updates
            if (wasReconnecting && taskId) {
              syncProgressFromPolling(taskId);
            }
          },
          onClose: () => {
            // Will trigger reconnection logic via shouldReconnect
          },
          onMessage: (event) => {
            try {
              const message: WebSocketMessage = JSON.parse(event.data);

              // Filter out heartbeat messages - just ignore them
              if (message.type === 'heartbeat') {
                return;
              }

              if (message.type === 'progress') {
                const progressMessage = message as ProgressMessage;
                onProgressRef.current?.(progressMessage.task_id, {
                  percentage: progressMessage.percentage,
                  stage: progressMessage.stage,
                  message: progressMessage.message,
                });

                if (progressMessage.stage === 'complete') {
                  onCompleteRef.current?.(progressMessage.task_id);
                }
              } else if (message.type === 'error') {
                const errorMessage = message as ErrorMessage;
                onErrorRef.current?.(errorMessage.task_id, {
                  errorCode: errorMessage.error_code,
                  userMessage: errorMessage.user_message,
                  technicalDetail: errorMessage.technical_detail,
                });
              }
            } catch (error) {
              console.error('Failed to parse WebSocket message:', error);
            }
          },
        },
        // Only connect when taskId is provided
        taskId !== null
      );

      // Update connection state based on readyState
      useEffect(() => {
        const isConnected = readyState === ReadyState.OPEN;
        const isConnecting = readyState === ReadyState.CONNECTING;
        const isReconnecting = isConnecting && wasConnectedRef.current;
        const maxAttemptsReached = reconnectAttemptRef.current >= MAX_RECONNECT_ATTEMPTS;

        setConnectionState({
          isConnected,
          isConnecting,
          isReconnecting,
          reconnectAttempt: reconnectAttemptRef.current,
          maxAttemptsReached,
        });
      }, [readyState]);

      /**
       * Manually trigger reconnection (after max attempts)
       */
      const reconnect = useCallback(() => {
        reconnectAttemptRef.current = 0;
        wasConnectedRef.current = false;
        const ws = getWebSocket();
        if (ws) {
          ws.close();
        }
        // WebSocket will auto-reconnect since we reset the counter
      }, [getWebSocket]);

      return {
        connectionState,
        reconnect,
      };
    }
    ```
  </action>
  <verify>
    - `bun run build` completes without errors
    - useTaskProgress.ts exports useTaskProgress function
    - Hook accepts taskId and callbacks in options
    - Returns connectionState and reconnect function
  </verify>
  <done>
    useTaskProgress hook created with WebSocket connection, exponential backoff reconnection, polling sync on reconnect, heartbeat filtering
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend useFileQueue with progress tracking</name>
  <files>frontend/src/hooks/useFileQueue.ts</files>
  <action>
    Update `frontend/src/hooks/useFileQueue.ts` to add progress tracking:

    1. Update the import to include ProgressStage:
       ```typescript
       import type { FileQueueItem, FileQueueItemStatus, ProgressStage } from '@/types/upload';
       ```

    2. Add new function for updating file progress (after updateFileStatus):
       ```typescript
       /**
        * Update file progress from WebSocket
        */
       const updateFileProgress = useCallback((
         id: string,
         progressPercentage: number,
         progressStage: ProgressStage
       ) => {
         setQueue(previousQueue =>
           previousQueue.map(item =>
             item.id === id ? { ...item, progressPercentage, progressStage } : item
           )
         );
       }, []);

       /**
        * Set backend task ID for a file (after upload starts)
        */
       const setFileTaskId = useCallback((id: string, taskId: string) => {
         setQueue(previousQueue =>
           previousQueue.map(item =>
             item.id === id ? { ...item, taskId } : item
           )
         );
       }, []);

       /**
        * Mark file as complete (reset progress display, set status)
        */
       const completeFile = useCallback((id: string) => {
         setQueue(previousQueue =>
           previousQueue.map(item =>
             item.id === id
               ? { ...item, status: 'complete' as const, progressStage: 'complete' as const }
               : item
           )
         );
       }, []);

       /**
        * Mark file as error with message
        */
       const setFileError = useCallback((
         id: string,
         errorMessage: string,
         technicalDetail?: string
       ) => {
         setQueue(previousQueue =>
           previousQueue.map(item =>
             item.id === id
               ? {
                   ...item,
                   status: 'error' as const,
                   errorMessage,
                   // Store technical detail for "Show details" feature
                   technicalDetail,
                 }
               : item
           )
         );
       }, []);
       ```

    3. Add technicalDetail to FileQueueItem type in upload.ts (after errorMessage):
       ```typescript
       /** Technical error details for debugging (shown via "Show details") */
       technicalDetail?: string;
       ```

    4. Update the return statement to include new functions:
       ```typescript
       return {
         queue,
         addFiles,
         removeFile,
         clearPendingFiles,
         updateFileSettings,
         updateFileStatus,
         updateFileProgress,
         setFileTaskId,
         completeFile,
         setFileError,
         isFileReady,
         pendingCount,
         readyCount,
         hasProcessingFiles,
       };
       ```

    5. Verify build passes: `bun run build`
  </action>
  <verify>
    - `bun run build` completes without errors
    - useFileQueue exports updateFileProgress, setFileTaskId, completeFile, setFileError functions
    - FileQueueItem type has technicalDetail field
  </verify>
  <done>
    useFileQueue extended with progress tracking functions: updateFileProgress, setFileTaskId, completeFile, setFileError
  </done>
</task>

</tasks>

<verification>
1. `bun run build` passes without errors
2. useTaskProgress hook connects to WebSocket when taskId provided
3. useTaskProgress implements exponential backoff reconnection
4. useFileQueue has all progress tracking functions
5. FileQueueItem supports taskId, progressPercentage, progressStage, technicalDetail fields
</verification>

<success_criteria>
- useTaskProgress hook created with WebSocket connection via react-use-websocket
- Reconnection with exponential backoff (1s, 2s, 4s, 8s, 16s) up to 5 attempts
- State sync on reconnect via GET /tasks/{taskId}/progress polling endpoint
- Heartbeat messages filtered and ignored
- Connection state exposed for UI (isConnected, isReconnecting, maxAttemptsReached)
- useFileQueue extended with progress tracking (updateFileProgress, setFileTaskId, completeFile, setFileError)
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-progress-tracking/05-02-SUMMARY.md`
</output>
