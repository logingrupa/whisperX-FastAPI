---
phase: 05-real-time-progress-tracking
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useTaskProgress.ts
  - frontend/src/hooks/useUploadOrchestration.ts
  - frontend/src/App.tsx
  - frontend/src/components/upload/FileQueueList.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Progress bar fills smoothly showing intermediate stages during processing"
    - "Stage badge shows Transcribing, Aligning, Diarizing stages with step count"
    - "Error state displays with red border and Retry button"
    - "Connection status indicator shows during reconnection attempts"
  artifacts:
    - path: "frontend/src/hooks/useTaskProgress.ts"
      provides: "Initial sync on WebSocket connect"
      contains: "syncProgressFromPolling(taskId)"
    - path: "frontend/src/hooks/useUploadOrchestration.ts"
      provides: "Exposed connectionState and reconnect"
      exports: ["connectionState", "reconnect"]
    - path: "frontend/src/App.tsx"
      provides: "ConnectionStatus rendered, handleRetry wired"
      contains: "ConnectionStatus"
    - path: "frontend/src/components/upload/FileQueueList.tsx"
      provides: "onRetry prop passed through"
      contains: "onRetry"
  key_links:
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/upload/ConnectionStatus.tsx"
      via: "JSX render with connectionState/reconnect props"
      pattern: "<ConnectionStatus"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/upload/FileQueueList.tsx"
      via: "onRetry prop"
      pattern: "onRetry=\\{handleRetry\\}"
    - from: "frontend/src/components/upload/FileQueueList.tsx"
      to: "frontend/src/components/upload/FileQueueItem.tsx"
      via: "onRetry prop"
      pattern: "onRetry=\\{onRetry\\}"
---

<objective>
Fix race condition where WebSocket progress updates are missed and wire up missing UI integrations.

Purpose: UAT revealed 5 issues from 2 root causes - backend emits progress before WebSocket connects, and ConnectionStatus/handleRetry never wired into component tree.

Output: Fully functional progress tracking with visible intermediate stages, error retry, and connection status indicator.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-real-time-progress-tracking/05-UAT.md

# Existing code to modify
@frontend/src/hooks/useTaskProgress.ts
@frontend/src/hooks/useUploadOrchestration.ts
@frontend/src/App.tsx
@frontend/src/components/upload/FileQueueList.tsx
@frontend/src/components/upload/FileQueueItem.tsx
@frontend/src/components/upload/ConnectionStatus.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix race condition - sync progress on initial WebSocket connect</name>
  <files>frontend/src/hooks/useTaskProgress.ts</files>
  <action>
In the onOpen callback of useWebSocket (around line 125-133), the code currently only calls syncProgressFromPolling when wasReconnecting is true:

```typescript
onOpen: () => {
  const wasReconnecting = wasConnectedRef.current;
  wasConnectedRef.current = true;
  reconnectAttemptRef.current = 0;

  // On reconnect, fetch current state to sync missed updates
  if (wasReconnecting && taskId) {
    syncProgressFromPolling(taskId);
  }
},
```

Change this to ALWAYS sync on connect (not just reconnect):

```typescript
onOpen: () => {
  wasConnectedRef.current = true;
  reconnectAttemptRef.current = 0;

  // Always sync progress on connect (initial or reconnect)
  // Backend may have emitted updates before WebSocket connected
  if (taskId) {
    syncProgressFromPolling(taskId);
  }
},
```

This ensures that even if the backend emits progress updates BEFORE the frontend WebSocket connects, the frontend will immediately fetch current state from the polling endpoint.
  </action>
  <verify>
- Code compiles: `cd frontend && bun run build`
- onOpen callback calls syncProgressFromPolling unconditionally when taskId exists
  </verify>
  <done>useTaskProgress syncs progress state on initial connect, not just reconnect</done>
</task>

<task type="auto">
  <name>Task 2: Wire ConnectionStatus and handleRetry through component tree</name>
  <files>
    frontend/src/hooks/useUploadOrchestration.ts
    frontend/src/App.tsx
    frontend/src/components/upload/FileQueueList.tsx
  </files>
  <action>
**Step 1: useUploadOrchestration.ts**

The hook already gets connectionState and reconnect from useTaskProgress but does not expose them. Update the return type and return statement.

1. Update the interface UseUploadOrchestrationReturn to include:
```typescript
interface UseUploadOrchestrationReturn extends UseFileQueueReturn {
  /** Start processing a single file */
  handleStartFile: (id: string) => void;
  /** Start processing all ready files */
  handleStartAll: () => void;
  /** Retry a failed file */
  handleRetry: (id: string) => void;
  /** WebSocket connection state */
  connectionState: ConnectionState;
  /** Manual reconnection trigger */
  reconnect: () => void;
}
```

2. Import ConnectionState type at the top:
```typescript
import { useTaskProgress, type TaskProgressState, type TaskErrorState, type ConnectionState } from './useTaskProgress';
```

3. Destructure connectionState and reconnect from useTaskProgress:
```typescript
const { connectionState, reconnect } = useTaskProgress({
  taskId: currentTaskId,
  onProgress: handleProgress,
  onError: handleError,
  onComplete: handleComplete,
});
```

4. Add to return object:
```typescript
return {
  ...fileQueue,
  handleStartFile,
  handleStartAll,
  handleRetry,
  connectionState,
  reconnect,
};
```

**Step 2: App.tsx**

1. Add import for ConnectionStatus:
```typescript
import { ConnectionStatus } from '@/components/upload/ConnectionStatus';
```

2. Destructure handleRetry, connectionState, and reconnect from useUploadOrchestration:
```typescript
const {
  queue,
  addFiles,
  removeFile,
  clearPendingFiles,
  updateFileSettings,
  pendingCount,
  readyCount,
  handleStartAll,
  handleStartFile,
  handleRetry,
  connectionState,
  reconnect,
} = useUploadOrchestration();
```

3. Render ConnectionStatus inside the UploadDropzone (before FileQueueList) and pass onRetry to FileQueueList:
```tsx
<UploadDropzone onFilesAdded={addFiles}>
  <ConnectionStatus
    connectionState={connectionState}
    onReconnect={reconnect}
  />
  {queue.length > 0 && (
    <FileQueueList
      queue={queue}
      onRemoveFile={removeFile}
      onUpdateSettings={updateFileSettings}
      onClearPending={clearPendingFiles}
      onStartAll={handleStartAll}
      onStartFile={handleStartFile}
      onRetry={handleRetry}
      pendingCount={pendingCount}
      readyCount={readyCount}
    />
  )}
</UploadDropzone>
```

**Step 3: FileQueueList.tsx**

1. Add onRetry to the props interface:
```typescript
interface FileQueueListProps {
  queue: FileQueueItemType[];
  onRemoveFile: (id: string) => void;
  onUpdateSettings: (
    id: string,
    updates: { selectedLanguage?: LanguageCode | ''; selectedModel?: WhisperModel }
  ) => void;
  onClearPending: () => void;
  onStartAll?: () => void;
  onStartFile?: (id: string) => void;
  onRetry?: (id: string) => void;  // Add this
  pendingCount: number;
  readyCount: number;
}
```

2. Destructure onRetry in function parameters:
```typescript
export function FileQueueList({
  queue,
  onRemoveFile,
  onUpdateSettings,
  onClearPending,
  onStartAll,
  onStartFile,
  onRetry,  // Add this
  pendingCount,
  readyCount,
}: FileQueueListProps) {
```

3. Pass onRetry to each FileQueueItem in the map:
```tsx
<FileQueueItem
  key={item.id}
  item={item}
  onRemove={onRemoveFile}
  onUpdateSettings={onUpdateSettings}
  onStart={onStartFile}
  onRetry={onRetry}
/>
```
  </action>
  <verify>
- Code compiles: `cd frontend && bun run build`
- Grep for ConnectionStatus in App.tsx: `grep "ConnectionStatus" frontend/src/App.tsx`
- Grep for onRetry in FileQueueList.tsx: `grep "onRetry" frontend/src/components/upload/FileQueueList.tsx`
  </verify>
  <done>
- ConnectionStatus component rendered in App.tsx with connectionState and reconnect props
- handleRetry passed from App.tsx to FileQueueList to FileQueueItem
- Error files show Retry button that triggers handleRetry
- Connection status indicator appears during WebSocket reconnection
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Build succeeds: `cd frontend && bun run build`

2. Code structure verification:
   - useTaskProgress.ts: syncProgressFromPolling called in onOpen without wasReconnecting check
   - useUploadOrchestration.ts: returns connectionState and reconnect
   - App.tsx: imports and renders ConnectionStatus, passes onRetry to FileQueueList
   - FileQueueList.tsx: accepts and passes onRetry prop

3. Functional verification (manual):
   - Start a transcription and observe intermediate stages (Transcribing, Aligning, Diarizing)
   - Progress bar fills smoothly with percentage updates
   - Kill backend during processing, observe error state with Retry button
   - Observe connection status indicator during reconnection attempts
</verification>

<success_criteria>
- Build passes with no TypeScript errors
- Progress updates visible immediately when processing starts (race condition fixed)
- Intermediate stages (Transcribing 2/5, Aligning 3/5, etc.) now visible
- Error state shows red border, error message, and working Retry button
- Connection status shows "Reconnecting... (attempt X/5)" during reconnection
- After 5 failed attempts, amber warning with manual Reconnect button appears
</success_criteria>

<output>
After completion, create `.planning/phases/05-real-time-progress-tracking/05-04-SUMMARY.md`
</output>
