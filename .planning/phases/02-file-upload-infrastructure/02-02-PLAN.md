---
phase: 02-file-upload-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/infrastructure/storage/magic_validator.py
  - app/infrastructure/storage/__init__.py
  - app/api/streaming_upload_api.py
  - app/core/exceptions.py

autonomous: true

must_haves:
  truths:
    - "System validates file format using magic bytes, not just extension"
    - "Spoofed files (wrong extension) are rejected with clear error message"
    - "Validation happens early (after first chunk) to fail fast"
  artifacts:
    - path: "app/infrastructure/storage/magic_validator.py"
      provides: "Magic byte validation utility"
      exports: ["validate_magic_bytes", "get_file_type_from_magic"]
    - path: "app/core/exceptions.py"
      provides: "FileFormatValidationError exception"
      contains: "class FileFormatValidationError"
  key_links:
    - from: "app/api/streaming_upload_api.py"
      to: "app/infrastructure/storage/magic_validator.py"
      via: "validate_magic_bytes import and call"
      pattern: "validate_magic_bytes.*header"
    - from: "app/infrastructure/storage/magic_validator.py"
      to: "puremagic"
      via: "puremagic.magic_string call"
      pattern: "puremagic\\.magic_string"
---

<objective>
Add server-side magic byte validation to verify file types beyond extension checking.

Purpose: Extension-only validation can be spoofed (malicious file with .mp3 extension). Magic byte validation examines the actual file header to confirm the file type matches expectations. Per RESEARCH.md, this is a critical security layer.

Output: Magic byte validation integrated into streaming upload that rejects files where extension doesn't match actual content type.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-file-upload-infrastructure/02-RESEARCH.md
@.planning/phases/02-file-upload-infrastructure/02-01-SUMMARY.md

# Files from Plan 01 to modify
@app/api/streaming_upload_api.py
@app/infrastructure/storage/streaming_target.py
@app/infrastructure/storage/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create magic byte validation utility</name>
  <files>
    app/infrastructure/storage/magic_validator.py
    app/infrastructure/storage/__init__.py
  </files>
  <action>
**Step 1: Create magic_validator.py**

Create `app/infrastructure/storage/magic_validator.py`:

```python
"""Magic byte validation for uploaded files."""

from pathlib import Path
from typing import Optional

import puremagic

from app.core.logging import logger

# Map of magic byte detected extensions to our allowed canonical extensions
# puremagic may return variants (.oga, .ogv, .mkv) that we normalize
MAGIC_TO_CANONICAL: dict[str, str] = {
    # Audio formats
    ".mp3": ".mp3",
    ".wav": ".wav",
    ".aac": ".aac",
    ".ogg": ".ogg",
    ".oga": ".ogg",  # OGG audio variant
    ".m4a": ".m4a",
    ".wma": ".wma",
    ".amr": ".amr",
    ".flac": ".flac",
    ".awb": ".awb",
    # Video formats
    ".mp4": ".mp4",
    ".m4v": ".mp4",  # MPEG-4 video variant
    ".mov": ".mov",
    ".qt": ".mov",  # QuickTime variant
    ".avi": ".avi",
    ".wmv": ".wmv",
    ".mkv": ".mkv",
    ".webm": ".webm",
    ".ogv": ".webm",  # OGG video -> treat as webm family
}

# Extensions we accept (must match upload_config.ALLOWED_UPLOAD_EXTENSIONS)
ALLOWED_MAGIC_EXTENSIONS = set(MAGIC_TO_CANONICAL.values())


def get_file_type_from_magic(file_header: bytes) -> Optional[str]:
    """
    Detect file type from magic bytes.

    Args:
        file_header: First 2048+ bytes of the file

    Returns:
        Canonical extension (e.g., ".mp3") if detected and allowed, None otherwise
    """
    if not file_header:
        return None

    try:
        results = puremagic.magic_string(file_header)
        if not results:
            logger.debug("No magic byte match found")
            return None

        # Results are sorted by confidence (highest first)
        for result in results:
            extension = result.extension.lower()
            if not extension.startswith("."):
                extension = f".{extension}"

            # Check if this is a known type
            canonical = MAGIC_TO_CANONICAL.get(extension)
            if canonical:
                logger.debug(
                    "Magic byte detection: %s -> %s (mime: %s)",
                    extension,
                    canonical,
                    result.mime_type,
                )
                return canonical

        # Log what we found but couldn't match
        logger.debug(
            "Magic bytes found non-audio/video type: %s",
            [r.extension for r in results[:3]],
        )
        return None

    except Exception as error:
        logger.warning("Magic byte detection failed: %s", error)
        return None


def validate_magic_bytes(
    file_path: Path,
    claimed_extension: str,
) -> tuple[bool, str, Optional[str]]:
    """
    Validate that file's magic bytes match claimed extension.

    Args:
        file_path: Path to the file to validate
        claimed_extension: The extension claimed by the upload (e.g., ".mp3")

    Returns:
        Tuple of (is_valid, message, detected_type)
        - is_valid: True if magic matches claimed extension
        - message: Human-readable result message
        - detected_type: The detected file type or None
    """
    # Read file header for magic detection
    try:
        with open(file_path, "rb") as file_handle:
            header = file_handle.read(8192)  # Read 8KB for reliable detection
    except OSError as error:
        return False, f"Could not read file: {error}", None

    if not header:
        return False, "File is empty", None

    # Detect actual type
    detected_type = get_file_type_from_magic(header)

    if detected_type is None:
        return (
            False,
            f"Unknown file format. Expected audio/video file, got unrecognized format.",
            None,
        )

    # Normalize claimed extension
    claimed_normalized = claimed_extension.lower()
    if not claimed_normalized.startswith("."):
        claimed_normalized = f".{claimed_normalized}"

    # Get canonical form of claimed extension
    claimed_canonical = MAGIC_TO_CANONICAL.get(claimed_normalized, claimed_normalized)

    # Compare canonical forms
    if detected_type == claimed_canonical:
        return True, f"Valid {detected_type} file", detected_type

    # Extension mismatch - possible spoofing attempt
    return (
        False,
        f"File format mismatch: claimed {claimed_extension} but detected {detected_type}",
        detected_type,
    )


def validate_magic_bytes_from_header(
    header: bytes,
    claimed_extension: str,
) -> tuple[bool, str, Optional[str]]:
    """
    Validate magic bytes from raw header bytes (for in-stream validation).

    Args:
        header: First bytes of the file (minimum 2048 recommended)
        claimed_extension: The extension claimed by the upload

    Returns:
        Tuple of (is_valid, message, detected_type)
    """
    if not header:
        return False, "No data to validate", None

    detected_type = get_file_type_from_magic(header)

    if detected_type is None:
        return (
            False,
            "Unknown file format. Expected audio/video file.",
            None,
        )

    # Normalize and compare
    claimed_normalized = claimed_extension.lower()
    if not claimed_normalized.startswith("."):
        claimed_normalized = f".{claimed_normalized}"

    claimed_canonical = MAGIC_TO_CANONICAL.get(claimed_normalized, claimed_normalized)

    if detected_type == claimed_canonical:
        return True, f"Valid {detected_type} file", detected_type

    return (
        False,
        f"File format mismatch: claimed {claimed_extension} but detected {detected_type}",
        detected_type,
    )
```

**Step 2: Update storage __init__.py**

Update `app/infrastructure/storage/__init__.py` to export the new functions:

```python
"""Storage infrastructure for file uploads."""

from app.infrastructure.storage.magic_validator import (
    get_file_type_from_magic,
    validate_magic_bytes,
    validate_magic_bytes_from_header,
)
from app.infrastructure.storage.streaming_target import StreamingFileTarget

__all__ = [
    "StreamingFileTarget",
    "get_file_type_from_magic",
    "validate_magic_bytes",
    "validate_magic_bytes_from_header",
]
```
  </action>
  <verify>
Run validation test:
```bash
python -c "
from app.infrastructure.storage import validate_magic_bytes_from_header

# Test with MP3 ID3 header
mp3_header = b'ID3' + b'\x00' * 100
valid, msg, detected = validate_magic_bytes_from_header(mp3_header, '.mp3')
print(f'MP3 test: valid={valid}, msg={msg}, detected={detected}')
"
```
  </verify>
  <done>Magic byte validation utility created with puremagic integration</done>
</task>

<task type="auto">
  <name>Task 2: Add FileFormatValidationError to exceptions</name>
  <files>app/core/exceptions.py</files>
  <action>
Add a new exception class for file format validation failures. This follows the existing exception hierarchy pattern in the codebase.

Find the existing exceptions in `app/core/exceptions.py` and add this new class after the `FileValidationError` class:

```python
class FileFormatValidationError(ValidationError):
    """Exception raised when file content doesn't match claimed format."""

    def __init__(
        self,
        filename: str,
        claimed_extension: str,
        detected_type: Optional[str],
        correlation_id: Optional[str] = None,
    ) -> None:
        if detected_type:
            message = (
                f"File format mismatch for '{filename}': "
                f"claimed {claimed_extension} but detected {detected_type}"
            )
            user_message = (
                f"The file '{filename}' appears to be a {detected_type} file, "
                f"not a {claimed_extension} file. Please upload a valid {claimed_extension} file."
            )
        else:
            message = (
                f"Unknown file format for '{filename}': "
                f"claimed {claimed_extension} but could not detect actual type"
            )
            user_message = (
                f"The file '{filename}' does not appear to be a valid audio/video file. "
                f"Supported formats: MP3, WAV, MP4, M4A, FLAC, OGG, WebM, MOV, AVI, MKV."
            )

        super().__init__(
            message=message,
            code="FILE_FORMAT_MISMATCH",
            user_message=user_message,
            correlation_id=correlation_id,
            filename=filename,
            claimed_extension=claimed_extension,
            detected_type=detected_type,
        )
```

Make sure to add `Optional` import from typing if not already present.
  </action>
  <verify>Run `python -c "from app.core.exceptions import FileFormatValidationError; print('OK')"`</verify>
  <done>FileFormatValidationError exception class added to exception hierarchy</done>
</task>

<task type="auto">
  <name>Task 3: Integrate magic validation into streaming upload</name>
  <files>app/api/streaming_upload_api.py</files>
  <action>
Update the streaming upload endpoint to perform magic byte validation after the upload completes.

Modify `app/api/streaming_upload_api.py`:

1. Add imports at the top:
```python
from app.infrastructure.storage.magic_validator import validate_magic_bytes
```

2. After the extension validation section and before renaming the file, add magic byte validation:

```python
    # Validate extension (existing code)
    extension = Path(original_filename).suffix.lower()
    if extension not in ALLOWED_UPLOAD_EXTENSIONS:
        temp_path.unlink(missing_ok=True)
        allowed_list = ", ".join(sorted(ALLOWED_UPLOAD_EXTENSIONS))
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Unsupported file format: {extension}. Allowed: {allowed_list}",
        )

    # NEW: Validate magic bytes to ensure file content matches extension
    is_valid, validation_message, detected_type = validate_magic_bytes(
        temp_path, extension
    )

    if not is_valid:
        # Clean up the uploaded file
        temp_path.unlink(missing_ok=True)
        logger.warning(
            "Magic byte validation failed for %s: %s",
            original_filename,
            validation_message,
        )
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=validation_message,
        )

    logger.debug("Magic byte validation passed: %s", validation_message)

    # Rename temp file with proper extension (existing code)
    final_path = UPLOAD_DIR / f"{upload_id}{extension}"
    temp_path.rename(final_path)
```

The validation happens AFTER the file is fully uploaded because:
1. We need enough bytes for reliable magic detection (at least 2KB, we read 8KB)
2. For streaming uploads, we don't buffer - the file goes straight to disk
3. Validation is still fast (just reads header) and happens before returning success
  </action>
  <verify>
Test with a spoofed file:
```bash
# Create a text file with .mp3 extension
echo "This is not an MP3 file" > /tmp/fake.mp3

# Try to upload - should fail with format mismatch
curl -X POST http://localhost:8000/upload/stream \
  -F "file=@/tmp/fake.mp3" \
  -w "\n%{http_code}\n"

# Should return 400 with "File format mismatch" or "Unknown file format" message
```

Test with a real audio file:
```bash
# Upload a real MP3 (if available)
curl -X POST http://localhost:8000/upload/stream \
  -F "file=@/path/to/real.mp3" \
  -w "\n%{http_code}\n"

# Should return 200 with upload details
```
  </verify>
  <done>
    - Magic byte validation integrated into streaming upload
    - Spoofed files (wrong extension) rejected with clear error
    - Validation happens after upload completes but before success response
    - Partial files cleaned up on validation failure
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Valid file upload:**
   ```bash
   # Use a real audio/video file
   curl -X POST http://localhost:8000/upload/stream \
     -F "file=@real_audio.mp3" \
     -w "\n%{http_code}\n"
   # Should return 200 with upload_id
   ```

2. **Spoofed extension rejection:**
   ```bash
   # Create text file with wrong extension
   echo "Not an MP3" > /tmp/spoofed.mp3
   curl -X POST http://localhost:8000/upload/stream \
     -F "file=@/tmp/spoofed.mp3" \
     -w "\n%{http_code}\n"
   # Should return 400 with format mismatch message
   ```

3. **Unsupported format rejection:**
   ```bash
   # Create file with unsupported extension
   echo "test" > /tmp/test.exe
   curl -X POST http://localhost:8000/upload/stream \
     -F "file=@/tmp/test.exe" \
     -w "\n%{http_code}\n"
   # Should return 400 with unsupported format message
   ```

4. **Exception import check:**
   ```bash
   python -c "from app.core.exceptions import FileFormatValidationError; print('OK')"
   ```
</verification>

<success_criteria>
- [ ] Magic validator utility created with puremagic integration
- [ ] Extension-to-canonical mapping handles variants (.oga -> .ogg, etc.)
- [ ] FileFormatValidationError exception added to hierarchy
- [ ] Streaming upload validates magic bytes after upload
- [ ] Spoofed files rejected with clear error message
- [ ] Valid files pass validation and upload successfully
- [ ] Failed validations clean up partial files
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-upload-infrastructure/02-02-SUMMARY.md`
</output>
