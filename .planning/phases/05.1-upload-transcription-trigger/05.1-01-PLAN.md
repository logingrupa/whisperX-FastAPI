---
phase: 05.1-upload-transcription-trigger
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/api/transcriptionApi.ts
  - frontend/src/types/api.ts
autonomous: true

must_haves:
  truths:
    - "API client can POST file with language and model to /service/transcribe"
    - "API client receives task ID from transcription response"
    - "API response types match backend schema exactly"
  artifacts:
    - path: "frontend/src/lib/api/transcriptionApi.ts"
      provides: "startTranscription function"
      exports: ["startTranscription"]
    - path: "frontend/src/types/api.ts"
      provides: "API response types"
      exports: ["TranscriptionResponse", "ApiError"]
  key_links:
    - from: "frontend/src/lib/api/transcriptionApi.ts"
      to: "/service/transcribe"
      via: "fetch with FormData"
      pattern: "fetch.*service/transcribe"
---

<objective>
Create API client for transcription endpoint

Purpose: Provide typed interface to backend transcription service for file upload and task creation
Output: API client module with startTranscription function and response types
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Backend endpoint reference:
- POST /service/transcribe
- Accepts: multipart/form-data with `file`, query params: `language`, `model`
- Returns: { identifier: string, message: string }

Frontend types already exist:
@frontend/src/types/upload.ts (LanguageCode, WhisperModel)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API response types</name>
  <files>frontend/src/types/api.ts</files>
  <action>
Create `frontend/src/types/api.ts` with:

```typescript
/**
 * API response types matching backend schemas
 */

/** Response from POST /service/transcribe */
export interface TranscriptionResponse {
  /** Task ID for WebSocket subscription */
  identifier: string;
  /** Status message (e.g., "Task queued") */
  message: string;
}

/** Standard API error response */
export interface ApiError {
  /** HTTP status code */
  status: number;
  /** Error detail from backend */
  detail: string;
}

/** Result type for API calls */
export type ApiResult<T> =
  | { success: true; data: T }
  | { success: false; error: ApiError };
```
  </action>
  <verify>File exists with correct exports: `bun run build` passes</verify>
  <done>API types file created with TranscriptionResponse, ApiError, ApiResult types</done>
</task>

<task type="auto">
  <name>Task 2: Create transcription API client</name>
  <files>frontend/src/lib/api/transcriptionApi.ts</files>
  <action>
Create `frontend/src/lib/api/` directory and `transcriptionApi.ts`:

```typescript
/**
 * API client for transcription service
 */
import type { LanguageCode, WhisperModel } from '@/types/upload';
import type { TranscriptionResponse, ApiResult, ApiError } from '@/types/api';

interface StartTranscriptionParams {
  /** File to transcribe */
  file: File;
  /** Language code (e.g., 'en', 'lv', 'ru') */
  language: LanguageCode;
  /** Whisper model size */
  model: WhisperModel;
}

/**
 * Start transcription for a file
 *
 * Posts file to /service/transcribe endpoint and returns task ID.
 * The task ID is used to subscribe to WebSocket progress updates.
 *
 * @param params - File, language, and model parameters
 * @returns Task ID on success, error details on failure
 */
export async function startTranscription(
  params: StartTranscriptionParams
): Promise<ApiResult<TranscriptionResponse>> {
  const { file, language, model } = params;

  // Build FormData with file
  const formData = new FormData();
  formData.append('file', file);

  // Build query params for model settings
  const queryParams = new URLSearchParams({
    language,
    model,
  });

  try {
    const response = await fetch(`/service/transcribe?${queryParams}`, {
      method: 'POST',
      body: formData,
      // Note: Don't set Content-Type header - browser sets it with boundary
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
      return {
        success: false,
        error: {
          status: response.status,
          detail: errorData.detail || `HTTP ${response.status}`,
        },
      };
    }

    const data: TranscriptionResponse = await response.json();
    return { success: true, data };

  } catch (error) {
    // Network error or other failure
    return {
      success: false,
      error: {
        status: 0,
        detail: error instanceof Error ? error.message : 'Network error',
      },
    };
  }
}
```
  </action>
  <verify>`bun run build` passes, file exports startTranscription function</verify>
  <done>Transcription API client created with typed startTranscription function</done>
</task>

</tasks>

<verification>
1. `bun run build` completes without errors
2. Types are correctly exported from frontend/src/types/api.ts
3. API client is correctly exported from frontend/src/lib/api/transcriptionApi.ts
4. No TypeScript errors in either file
</verification>

<success_criteria>
- API types file exists with TranscriptionResponse, ApiError, ApiResult
- API client file exists with startTranscription function
- Build passes without errors
- Types correctly match backend response schema
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-upload-transcription-trigger/05.1-01-SUMMARY.md`
</output>
