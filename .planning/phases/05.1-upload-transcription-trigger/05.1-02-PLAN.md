---
phase: 05.1-upload-transcription-trigger
plan: 02
type: execute
wave: 2
depends_on: ["05.1-01"]
files_modified:
  - frontend/src/hooks/useUploadOrchestration.ts
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can click Start All to upload and transcribe all ready files"
    - "User can click individual file start button to upload and transcribe that file"
    - "Progress updates flow through WebSocket during transcription"
    - "Error states are displayed when upload or transcription fails"
    - "File status transitions: pending -> uploading -> processing -> complete/error"
  artifacts:
    - path: "frontend/src/hooks/useUploadOrchestration.ts"
      provides: "Upload orchestration hook"
      exports: ["useUploadOrchestration"]
    - path: "frontend/src/App.tsx"
      provides: "Main app with working Start buttons"
      contains: "useUploadOrchestration"
  key_links:
    - from: "frontend/src/hooks/useUploadOrchestration.ts"
      to: "startTranscription"
      via: "import from api"
      pattern: "import.*startTranscription"
    - from: "frontend/src/hooks/useUploadOrchestration.ts"
      to: "useTaskProgress"
      via: "WebSocket subscription"
      pattern: "useTaskProgress"
    - from: "frontend/src/App.tsx"
      to: "useUploadOrchestration"
      via: "hook usage"
      pattern: "useUploadOrchestration"
---

<objective>
Wire Start buttons to upload files and trigger transcription with progress tracking

Purpose: Complete the upload-to-transcription flow so users can actually process their files
Output: Working upload orchestration with WebSocket progress updates
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05.1-upload-transcription-trigger/05.1-01-SUMMARY.md

Existing hooks to use:
@frontend/src/hooks/useFileQueue.ts (queue state, updateFileStatus, setFileTaskId, etc.)
@frontend/src/hooks/useTaskProgress.ts (WebSocket connection for progress)

API client from Plan 01:
@frontend/src/lib/api/transcriptionApi.ts (startTranscription)

Current App.tsx has stub handlers:
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload orchestration hook</name>
  <files>frontend/src/hooks/useUploadOrchestration.ts</files>
  <action>
Create `frontend/src/hooks/useUploadOrchestration.ts`:

```typescript
/**
 * Hook for orchestrating file upload and transcription workflow
 *
 * Coordinates:
 * - File queue state (useFileQueue)
 * - API calls (startTranscription)
 * - WebSocket progress (useTaskProgress)
 *
 * Flow:
 * 1. User clicks Start -> status: 'uploading'
 * 2. API call to /service/transcribe
 * 3. Get task ID -> connect WebSocket -> status: 'processing'
 * 4. Receive progress updates via WebSocket
 * 5. Complete or error state
 */
import { useCallback, useRef, useEffect } from 'react';
import { useFileQueue, type UseFileQueueReturn } from './useFileQueue';
import { useTaskProgress, type TaskProgressState, type TaskErrorState } from './useTaskProgress';
import { startTranscription } from '@/lib/api/transcriptionApi';
import type { FileQueueItem } from '@/types/upload';

interface UseUploadOrchestrationReturn extends UseFileQueueReturn {
  /** Start processing a single file */
  handleStartFile: (id: string) => void;
  /** Start processing all ready files */
  handleStartAll: () => void;
  /** Retry a failed file */
  handleRetry: (id: string) => void;
}

/**
 * Orchestrates the upload -> transcribe -> progress flow
 */
export function useUploadOrchestration(): UseUploadOrchestrationReturn {
  const fileQueue = useFileQueue();
  const {
    queue,
    updateFileStatus,
    updateFileProgress,
    setFileTaskId,
    completeFile,
    setFileError,
    isFileReady,
  } = fileQueue;

  // Track current file being processed for WebSocket subscription
  const currentFileIdRef = useRef<string | null>(null);
  const currentTaskIdRef = useRef<string | null>(null);

  // Find the file item for current processing
  const currentFile = queue.find(item => item.id === currentFileIdRef.current);
  const currentTaskId = currentFile?.taskId ?? null;

  // Progress callback - update file progress from WebSocket
  const handleProgress = useCallback((taskId: string, progress: TaskProgressState) => {
    const fileId = currentFileIdRef.current;
    if (!fileId) return;

    // Map WebSocket stage to our status
    if (progress.stage === 'uploading') {
      updateFileStatus(fileId, 'uploading');
    } else if (progress.stage !== 'complete') {
      updateFileStatus(fileId, 'processing');
    }

    updateFileProgress(fileId, progress.percentage, progress.stage);
  }, [updateFileStatus, updateFileProgress]);

  // Error callback - set file error from WebSocket
  const handleError = useCallback((taskId: string, error: TaskErrorState) => {
    const fileId = currentFileIdRef.current;
    if (!fileId) return;

    setFileError(fileId, error.userMessage, error.technicalDetail ?? undefined);

    // Clear current processing
    currentFileIdRef.current = null;
    currentTaskIdRef.current = null;
  }, [setFileError]);

  // Complete callback - mark file as complete
  const handleComplete = useCallback((taskId: string) => {
    const fileId = currentFileIdRef.current;
    if (!fileId) return;

    completeFile(fileId);

    // Clear current processing
    currentFileIdRef.current = null;
    currentTaskIdRef.current = null;
  }, [completeFile]);

  // WebSocket connection for current task
  useTaskProgress({
    taskId: currentTaskId,
    onProgress: handleProgress,
    onError: handleError,
    onComplete: handleComplete,
  });

  /**
   * Process a single file: upload -> get task ID -> start WebSocket
   */
  const processFile = useCallback(async (item: FileQueueItem) => {
    // Validate file is ready
    if (!isFileReady(item)) {
      console.warn('File not ready:', item.id);
      return;
    }

    // Set as current processing file
    currentFileIdRef.current = item.id;

    // Update status to uploading
    updateFileStatus(item.id, 'uploading');
    updateFileProgress(item.id, 0, 'uploading');

    // Call transcription API
    const result = await startTranscription({
      file: item.file,
      language: item.selectedLanguage as Exclude<typeof item.selectedLanguage, ''>,
      model: item.selectedModel,
    });

    if (!result.success) {
      // API error - set file error state
      setFileError(
        item.id,
        'Upload failed',
        result.error.detail
      );
      currentFileIdRef.current = null;
      return;
    }

    // Success - store task ID for WebSocket subscription
    const taskId = result.data.identifier;
    setFileTaskId(item.id, taskId);
    currentTaskIdRef.current = taskId;

    // Update status to processing (WebSocket will take over progress updates)
    updateFileStatus(item.id, 'processing');
    updateFileProgress(item.id, 5, 'queued');
  }, [isFileReady, updateFileStatus, updateFileProgress, setFileTaskId, setFileError]);

  /**
   * Start processing a single file by ID
   */
  const handleStartFile = useCallback((id: string) => {
    const item = queue.find(f => f.id === id);
    if (!item) {
      console.warn('File not found:', id);
      return;
    }
    processFile(item);
  }, [queue, processFile]);

  /**
   * Start processing all ready files (FIFO order)
   * Note: For MVP, processes one file at a time
   * Future: Could implement parallel processing
   */
  const handleStartAll = useCallback(() => {
    // Find first ready file
    const readyFile = queue.find(isFileReady);
    if (readyFile) {
      processFile(readyFile);
    }
  }, [queue, isFileReady, processFile]);

  /**
   * Retry a failed file (reset status and process again)
   */
  const handleRetry = useCallback((id: string) => {
    const item = queue.find(f => f.id === id);
    if (!item || item.status !== 'error') {
      console.warn('Cannot retry - file not in error state:', id);
      return;
    }

    // Reset to pending, then start
    updateFileStatus(id, 'pending');

    // Small delay to allow state update, then process
    setTimeout(() => {
      const updatedItem = queue.find(f => f.id === id);
      if (updatedItem && updatedItem.selectedLanguage) {
        processFile({
          ...updatedItem,
          status: 'pending',
          errorMessage: undefined,
          technicalDetail: undefined,
        });
      }
    }, 0);
  }, [queue, updateFileStatus, processFile]);

  // Auto-process next ready file when current completes
  useEffect(() => {
    // Only trigger when we're not currently processing
    if (currentFileIdRef.current !== null) return;

    // Check if there's a processing file that just completed
    const hasProcessingOrUploading = queue.some(
      item => item.status === 'uploading' || item.status === 'processing'
    );
    if (hasProcessingOrUploading) return;

    // Find next ready file (for "Start All" continuation)
    // Only auto-continue if we have files in non-pending states (meaning user started batch)
    const hasStartedFiles = queue.some(
      item => item.status === 'complete' || item.status === 'error'
    );
    if (!hasStartedFiles) return;

    const nextReady = queue.find(isFileReady);
    if (nextReady) {
      processFile(nextReady);
    }
  }, [queue, isFileReady, processFile]);

  return {
    ...fileQueue,
    handleStartFile,
    handleStartAll,
    handleRetry,
  };
}
```
  </action>
  <verify>`bun run build` passes, hook exports correctly</verify>
  <done>Upload orchestration hook created with handleStartFile, handleStartAll, handleRetry</done>
</task>

<task type="auto">
  <name>Task 2: Update App.tsx to use orchestration hook</name>
  <files>frontend/src/App.tsx</files>
  <action>
Replace the contents of `frontend/src/App.tsx` with:

```typescript
import { UploadDropzone } from '@/components/upload/UploadDropzone';
import { FileQueueList } from '@/components/upload/FileQueueList';
import { useUploadOrchestration } from '@/hooks/useUploadOrchestration';

/**
 * Main upload page
 *
 * Integrates:
 * - UploadDropzone for drag-drop and file selection
 * - FileQueueList for queue display and management
 * - useUploadOrchestration for upload -> transcribe -> progress flow
 */
function App() {
  const {
    queue,
    addFiles,
    removeFile,
    clearPendingFiles,
    updateFileSettings,
    pendingCount,
    readyCount,
    handleStartAll,
    handleStartFile,
    handleRetry,
  } = useUploadOrchestration();

  return (
    <UploadDropzone onFilesAdded={addFiles}>
      {queue.length > 0 && (
        <FileQueueList
          queue={queue}
          onRemoveFile={removeFile}
          onUpdateSettings={updateFileSettings}
          onClearPending={clearPendingFiles}
          onStartAll={handleStartAll}
          onStartFile={handleStartFile}
          pendingCount={pendingCount}
          readyCount={readyCount}
        />
      )}
    </UploadDropzone>
  );
}

export default App;
```

Note: The FileQueueList component already passes onStartFile to FileQueueItem as onStart, and FileQueueItem already has the onRetry prop support from Phase 5. We don't need to wire onRetry at this level yet - it can be added to FileQueueList props if needed for batch retry functionality.
  </action>
  <verify>`bun run build` passes, App uses useUploadOrchestration</verify>
  <done>App.tsx updated to use orchestration hook with working Start buttons</done>
</task>

</tasks>

<verification>
1. `bun run build` completes without errors
2. useUploadOrchestration hook exports correctly
3. App.tsx imports and uses useUploadOrchestration
4. handleStartFile and handleStartAll are wired to UI buttons
5. TypeScript types are correct throughout
</verification>

<success_criteria>
- Upload orchestration hook created with full flow
- App.tsx uses orchestration hook instead of stubs
- Build passes without errors
- Start buttons trigger actual upload and transcription
- WebSocket progress updates are received and displayed
- Error states are properly handled and displayed
</success_criteria>

<output>
After completion, create `.planning/phases/05.1-upload-transcription-trigger/05.1-02-SUMMARY.md`
</output>
