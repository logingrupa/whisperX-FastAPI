---
phase: 03-build-integration-spa-serving
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/spa_handler.py
  - app/main.py
  - package.json
  - bun.lock
autonomous: true

must_haves:
  truths:
    - "FastAPI serves index.html at /ui route"
    - "FastAPI serves built assets at /ui/assets/*"
    - "Page refresh on /ui/any-route returns index.html (not 404)"
    - "Single command starts both Vite and FastAPI"
    - "API calls from frontend reach FastAPI backend"
  artifacts:
    - path: "app/spa_handler.py"
      provides: "SPA routing and static file serving"
      exports: ["setup_spa_routes"]
    - path: "package.json"
      provides: "Root dev commands with concurrently"
      contains: "concurrently"
    - path: "app/main.py"
      provides: "FastAPI app with SPA routes"
      contains: "setup_spa_routes"
  key_links:
    - from: "app/main.py"
      to: "app/spa_handler.py"
      via: "function import and call"
      pattern: "from app.spa_handler import setup_spa_routes"
    - from: "app/spa_handler.py"
      to: "frontend/dist"
      via: "Path reference"
      pattern: 'frontend.*dist'
    - from: "package.json"
      to: "uvicorn"
      via: "dev:api script"
      pattern: "uvicorn app.main:app"
---

<objective>
Create FastAPI SPA handler for serving the React frontend and root-level dev commands for concurrent development.

Purpose: Enables the frontend to be served from FastAPI in production and provides a single-command development workflow. The catch-all route ensures React Router works correctly with page refreshes.

Output: SPA handler module, updated main.py, and root package.json with dev scripts.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-build-integration-spa-serving/03-RESEARCH.md
@.planning/phases/03-build-integration-spa-serving/03-01-SUMMARY.md
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI SPA Handler Module</name>
  <files>
    app/spa_handler.py
  </files>
  <action>
Create app/spa_handler.py with a setup_spa_routes function that configures SPA serving:

1. Define setup_spa_routes(app: FastAPI, frontend_path: Path | None = None) function:
   - Default frontend_path to Path(__file__).parent.parent / "frontend" / "dist"
   - Check if frontend_path exists; if not, log warning and return early
   - Check if index.html exists; if not, log error and return

2. Mount static assets directory:
   - Mount at "/ui/assets" using StaticFiles(directory=assets_path)
   - Only mount if assets_path exists
   - Mount BEFORE catch-all routes (order matters for routing)

3. Create catch-all routes for SPA:
   - @app.get("/ui") - serve index.html (no trailing slash)
   - @app.get("/ui/") - serve index.html (with trailing slash)
   - @app.get("/ui/{path:path}") - catch-all for client-side routes

4. Catch-all logic:
   - Check if requested path exists as file in frontend_path
   - If exists and is file, serve it (FileResponse)
   - Otherwise, serve index.html (for React Router)

5. Add logging:
   - Info log when SPA routes configured
   - Warning log when dist not found
   - Error log when index.html missing

Per research: StaticFiles must be mounted on main app, not APIRouter. Catch-all must come AFTER static mounts.
  </action>
  <verify>
    - app/spa_handler.py exists with setup_spa_routes function
    - Function handles missing dist gracefully (logs warning, doesn't crash)
    - Type hints present (FastAPI, Path, FileResponse)
  </verify>
  <done>
    - setup_spa_routes function created
    - Handles /ui, /ui/, and /ui/{path} routes
    - Static assets mounted at /ui/assets
    - Graceful handling when dist doesn't exist
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Root package.json with Dev Commands</name>
  <files>
    package.json
  </files>
  <action>
Create package.json in project root with development scripts:

1. Basic package.json structure:
   ```json
   {
     "name": "whisperx-dev",
     "private": true,
     "scripts": {
       "dev": "concurrently -n api,ui -c blue,green \"bun run dev:api\" \"bun run dev:ui\"",
       "dev:api": "uvicorn app.main:app --reload --host localhost --port 8000",
       "dev:ui": "cd frontend && bunx --bun vite --port 5173",
       "build:ui": "cd frontend && bunx --bun vite build",
       "preview:ui": "cd frontend && bunx --bun vite preview"
     },
     "devDependencies": {
       "concurrently": "^9.1.0"
     }
   }
   ```

2. Install concurrently:
   ```bash
   cd C:\laragon\www\whisperx
   bun install
   ```

3. Script explanations:
   - dev: Runs both API and UI concurrently with colored labels
   - dev:api: Runs uvicorn with hot-reload on port 8000
   - dev:ui: Runs Vite dev server on port 5173
   - build:ui: Builds frontend for production
   - preview:ui: Previews production build locally

Per user decision: Single command starts both frontend and backend together.
  </action>
  <verify>
    - package.json exists in project root
    - `bun run dev` starts both servers (will error if FastAPI not ready, that's expected)
    - concurrently installed in node_modules
  </verify>
  <done>
    - Root package.json created with all scripts
    - concurrently installed as dev dependency
    - bun run dev:api starts uvicorn
    - bun run dev:ui starts Vite
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire SPA Handler into main.py</name>
  <files>
    app/main.py
  </files>
  <action>
Update app/main.py to use the SPA handler:

1. Add import at top (after other imports):
   ```python
   from app.spa_handler import setup_spa_routes
   ```

2. Call setup_spa_routes AFTER all API routes are registered:
   - Place after all app.include_router() calls
   - Place after all @app.get() endpoint definitions
   - This ensures API routes take precedence over catch-all

3. Add the call:
   ```python
   # Setup SPA routes (must be last - catch-all for client-side routing)
   setup_spa_routes(app)
   ```

4. Verify placement:
   - AFTER: app.include_router(streaming_upload_router)
   - AFTER: @app.get("/health/ready") definition
   - Should be near end of file

Per research: Catch-all route must be registered AFTER API routes and static mounts to avoid intercepting API calls.
  </action>
  <verify>
    - app/main.py imports setup_spa_routes
    - setup_spa_routes(app) called after all routers
    - `uvicorn app.main:app --reload` starts without import errors
    - /health endpoint still works (not caught by SPA handler)
  </verify>
  <done>
    - SPA handler imported in main.py
    - setup_spa_routes called at end of route registration
    - API routes still accessible (/health returns JSON)
    - /ui returns warning log (dist not built yet)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `uvicorn app.main:app --reload` starts without errors
2. GET /health returns JSON (not caught by SPA)
3. Log shows "Frontend dist folder not found" warning (expected before build)
4. `bun run build:ui` creates frontend/dist/
5. After build: GET /ui returns index.html
6. After build: GET /ui/any-path returns index.html (SPA routing)
7. `bun run dev` starts both servers concurrently
</verification>

<success_criteria>
- SPA handler gracefully handles missing dist (logs warning, doesn't crash)
- API routes take precedence over SPA catch-all
- /ui serves index.html after frontend build
- /ui/{any-path} returns index.html for client-side routing
- Single `bun run dev` command starts full stack
- Build command `bun run build:ui` creates production assets
</success_criteria>

<output>
After completion, create `.planning/phases/03-build-integration-spa-serving/03-02-SUMMARY.md`
</output>
