---
phase: 07-backend-chunk-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - app/services/upload_session_service.py
  - app/api/tus_upload_api.py
autonomous: true

must_haves:
  truths:
    - "When final chunk is received, transcription starts automatically in the background"
    - "Assembled file is validated with magic bytes before transcription"
    - "Upload completion returns quickly (not blocked by transcription)"
    - "Transcription progress is emitted via WebSocket for TUS uploads"
    - "Task appears in /tasks endpoint after TUS upload completes"
  artifacts:
    - path: "app/services/upload_session_service.py"
      provides: "Bridge between TUS completion and existing transcription pipeline"
      contains: "UploadSessionService"
    - path: "app/api/tus_upload_api.py"
      provides: "TUS router with wired upload_complete_dep hook"
      contains: "upload_complete_dep"
  key_links:
    - from: "app/services/upload_session_service.py"
      to: "app/services/whisperx_wrapper_service.py"
      via: "process_audio_common import"
      pattern: "from app.services.*import process_audio_common"
    - from: "app/services/upload_session_service.py"
      to: "app/infrastructure/storage/magic_validator.py"
      via: "validate_magic_bytes import"
      pattern: "validate_magic_bytes"
    - from: "app/api/tus_upload_api.py"
      to: "app/services/upload_session_service.py"
      via: "DI hook factory"
      pattern: "upload_complete_dep=create_upload_complete_hook"
---

<objective>
Create the upload session service that bridges TUS upload completion to the existing transcription pipeline, and wire it as the upload_complete_dep hook in the TUS router.

Purpose: Without this hook, uploaded files just sit on disk. This plan makes TUS uploads trigger the same transcription pipeline that /speech-to-text uses, so users get results automatically.
Output: Working end-to-end flow from TUS upload completion to transcription task creation.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-backend-chunk-infrastructure/07-RESEARCH.md
@.planning/phases/07-backend-chunk-infrastructure/07-01-SUMMARY.md
@app/services/whisperx_wrapper_service.py
@app/api/audio_api.py
@app/core/upload_config.py
@app/domain/entities/task.py
@app/infrastructure/storage/magic_validator.py
@app/audio.py
@app/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UploadSessionService</name>
  <files>
    app/services/upload_session_service.py
  </files>
  <action>
    Create `app/services/upload_session_service.py` with an `UploadSessionService` class that bridges TUS upload completion to the existing transcription pipeline.

    The service must:
    1. Accept a completed file path (str from tuspyserver) and metadata dict (from TUS client)
    2. Validate the assembled file using `validate_magic_bytes` from `app.infrastructure.storage.magic_validator` - pass the file path and derive extension from metadata `filename` key. If invalid, log error and return (don't crash the hook).
    3. Load the audio using `process_audio_file` from `app.audio` and get duration with `get_audio_duration`
    4. Create a `DomainTask` entity (from `app.domain.entities.task`) with:
       - uuid from `uuid4()`
       - status = TaskStatus.processing
       - file_name from metadata.get("filename", Path(file_path).name)
       - audio_duration from the loaded audio
       - language from metadata.get("language", "auto") -- use "auto" if not specified
       - task_type = TaskType.full_process
       - created_at = datetime.now(timezone.utc)
    5. Save the task via the repository: `repository.add(task)` to get the identifier
    6. Build `SpeechToTextProcessingParams` with default parameters (same defaults as audio_api.py uses - WhisperModelParams(), AlignmentParams(), DiarizationParams(), ASROptions(), VADOptions()):
       - Set language from metadata if provided
       - Set identifier from the saved task
       - Set audio from loaded audio
       - Set callback_url to None (TUS uploads use WebSocket for progress)
    7. Schedule `process_audio_common` as a background task using `BackgroundTasks.add_task()`
    8. Return the task identifier string

    CRITICAL: The hook must NOT block. Transcription runs in background. The hook returns quickly.

    CRITICAL: Wrap everything in try/except. If validation or audio loading fails, log the error and raise (tuspyserver will handle it). Do NOT let errors silently swallow -- the file is already uploaded, but the user needs to know transcription failed.

    Follow existing patterns from audio_api.py for task creation and process_audio_common invocation.
    Follow SRP: this service only bridges TUS to transcription. No TUS protocol logic, no chunk handling.
    Use Google-style docstrings, type hints everywhere, absolute imports.
  </action>
  <verify>
    Run `python -c "from app.services.upload_session_service import UploadSessionService; print('OK')"` succeeds.
    Run mypy if configured: `python -m mypy app/services/upload_session_service.py --ignore-missing-imports` passes (or note issues).
  </verify>
  <done>
    UploadSessionService is importable, has a `start_transcription` method that accepts file_path, metadata, and background_tasks, creates a task, and schedules process_audio_common.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire upload_complete_dep hook into TUS router</name>
  <files>
    app/api/tus_upload_api.py
  </files>
  <action>
    Update `app/api/tus_upload_api.py` (created in Plan 01) to wire the real upload completion hook:

    1. Import dependencies:
       - `BackgroundTasks` from fastapi
       - `Depends` from fastapi
       - `get_task_repository` from `app.api.dependencies`
       - `UploadSessionService` from `app.services.upload_session_service`
       - `ITaskRepository` from `app.domain.repositories.task_repository`

    2. Create the DI factory function `create_upload_complete_hook`:
       - Parameters: `background_tasks: BackgroundTasks`, `repository: ITaskRepository = Depends(get_task_repository)`
       - Inside: instantiate `UploadSessionService(repository)`
       - Return an async handler function that calls `service.start_transcription(file_path, metadata, background_tasks)`
       - The handler signature must match what tuspyserver expects: `async def handler(file_path: str, metadata: dict) -> None`

    3. Update the `create_tus_router()` call to pass `upload_complete_dep=create_upload_complete_hook`
       - Remove the previous `upload_complete_dep=None` placeholder

    4. The handler must log at INFO level when triggered: "TUS upload complete: {file_path}, triggering transcription"
       Use `from app.core.logging import logger`

    IMPORTANT: tuspyserver's `upload_complete_dep` uses FastAPI's dependency injection. The factory function itself is the dependency -- FastAPI resolves its parameters (BackgroundTasks, repository) automatically.
  </action>
  <verify>
    1. Run `python -c "from app.api.tus_upload_api import tus_upload_router; print('Router with hook OK')"` succeeds.
    2. Verify the hook is wired: `python -c "from app.api.tus_upload_api import tus_upload_router; print('Loaded')"` -- no import errors.
  </verify>
  <done>
    TUS router's upload_complete_dep is wired to create_upload_complete_hook. When a TUS upload completes, the hook validates the file, creates a task, and schedules background transcription via process_audio_common.
  </done>
</task>

</tasks>

<verification>
1. All imports resolve without errors
2. UploadSessionService follows SRP (bridges TUS to transcription only)
3. The hook does NOT block -- transcription is scheduled as background task
4. File validation uses existing validate_magic_bytes (DRY)
5. Task creation follows same pattern as audio_api.py (DRY)
6. Integration test (manual): upload a file via TUS client, verify task appears in /tasks endpoint
</verification>

<success_criteria>
- UploadSessionService creates task and schedules process_audio_common
- TUS router hook triggers on upload completion
- Assembled file validated before transcription
- Task visible via GET /tasks after TUS upload
- Background transcription emits WebSocket progress updates
- No blocking in the upload completion hook
</success_criteria>

<output>
After completion, create `.planning/phases/07-backend-chunk-infrastructure/07-02-SUMMARY.md`
</output>
