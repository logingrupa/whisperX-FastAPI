---
phase: 08-frontend-chunking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/upload/constants.ts
  - frontend/src/lib/upload/tusUpload.ts
  - frontend/src/lib/upload/uploadMetrics.ts
  - frontend/vite.config.ts
  - app/services/upload_session_service.py
autonomous: true

must_haves:
  truths:
    - "tus-js-client is installed and importable in frontend"
    - "TUS upload wrapper creates upload with correct endpoint, chunkSize, and metadata"
    - "Speed tracker produces smoothed MB/s and ETA from raw byte progress"
    - "Vite dev proxy forwards /uploads requests to backend"
    - "Backend uses client-provided taskId from TUS metadata instead of generating one"
  artifacts:
    - path: "frontend/src/lib/upload/constants.ts"
      provides: "Size threshold (80MB), chunk size (50MB), TUS endpoint URL"
    - path: "frontend/src/lib/upload/tusUpload.ts"
      provides: "createTusUpload factory wrapping tus-js-client"
    - path: "frontend/src/lib/upload/uploadMetrics.ts"
      provides: "UploadSpeedTracker class with EMA smoothing"
    - path: "frontend/vite.config.ts"
      provides: "/uploads proxy entry for development"
    - path: "app/services/upload_session_service.py"
      provides: "taskId from TUS metadata used as task UUID"
  key_links:
    - from: "frontend/src/lib/upload/tusUpload.ts"
      to: "tus-js-client"
      via: "import * as tus from 'tus-js-client'"
      pattern: "new tus\\.Upload"
    - from: "frontend/src/lib/upload/tusUpload.ts"
      to: "frontend/src/lib/upload/constants.ts"
      via: "import { TUS_CHUNK_SIZE, TUS_ENDPOINT }"
      pattern: "TUS_CHUNK_SIZE|TUS_ENDPOINT"
    - from: "app/services/upload_session_service.py"
      to: "TUS metadata taskId"
      via: "metadata.get('taskId')"
      pattern: "metadata\\.get.*taskId"
---

<objective>
Create TUS upload foundation: library wrappers, speed metrics, Vite proxy, and backend taskId handoff.

Purpose: Provides the building blocks that Plan 02 (orchestration routing) and Plan 03 (progress UI) depend on. Solves the critical task ID handoff problem identified in research.
Output: tus-js-client installed, upload wrapper, speed tracker, proxy config, backend taskId support.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-frontend-chunking/08-RESEARCH.md
@.planning/phases/08-frontend-chunking/08-CONTEXT.md
@.planning/phases/07-backend-chunk-infrastructure/07-02-SUMMARY.md

Key existing files:
@frontend/vite.config.ts
@app/services/upload_session_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install tus-js-client and create upload library modules</name>
  <files>
    frontend/src/lib/upload/constants.ts
    frontend/src/lib/upload/tusUpload.ts
    frontend/src/lib/upload/uploadMetrics.ts
  </files>
  <action>
    1. Install tus-js-client in the frontend:
       ```bash
       cd frontend && bun add tus-js-client
       ```

    2. Create `frontend/src/lib/upload/constants.ts`:
       - `SIZE_THRESHOLD = 80 * 1024 * 1024` (80MB - files >= this use TUS)
       - `TUS_CHUNK_SIZE = 50 * 1024 * 1024` (50MB chunks for Cloudflare safety)
       - `TUS_ENDPOINT = '/uploads/files/'` (matches tuspyserver router mount from Phase 7)
       - `TUS_RETRY_DELAYS = [0, 1000, 3000, 5000]` (built-in retry for Phase 8)
       - Export all as named exports

    3. Create `frontend/src/lib/upload/uploadMetrics.ts`:
       - Export `UploadMetrics` interface: `{ percentage: number; speedBytesPerSecond: number; speedFormatted: string; etaSeconds: number; etaFormatted: string }`
       - Export `UploadSpeedTracker` class:
         - Private fields: `lastTimestamp`, `lastBytes`, `smoothedSpeed`, `alpha = 0.3` (EMA factor)
         - `update(bytesSent: number, bytesTotal: number): UploadMetrics` method
         - First call: return "Calculating..." / "-- MB/s" (need two data points)
         - Skip updates if < 500ms since last update (avoid jitter)
         - Use exponential moving average: `smoothedSpeed = alpha * instantSpeed + (1 - alpha) * smoothedSpeed`
         - ETA: `(bytesTotal - bytesSent) / smoothedSpeed`
         - `reset(): void` method to clear state between files
       - Export `formatSpeed(bytesPerSecond: number): string` (e.g., "12.3 MB/s")
       - Export `formatEta(seconds: number): string` (e.g., "2m 15s", "< 1m", "Calculating...")
       - Use pattern from 08-RESEARCH.md code example but with full type safety

    4. Create `frontend/src/lib/upload/tusUpload.ts`:
       - Import `* as tus from 'tus-js-client'`
       - Import constants from `./constants`
       - Export `TusUploadCallbacks` interface: `{ onProgress(bytesSent: number, bytesTotal: number): void; onSuccess(tusUrl: string): void; onError(error: Error): void }`
       - Export `createTusUpload(file: File, metadata: Record<string, string>, callbacks: TusUploadCallbacks): tus.Upload`
         - Creates `new tus.Upload(file, { endpoint: TUS_ENDPOINT, chunkSize: TUS_CHUNK_SIZE, retryDelays: TUS_RETRY_DELAYS, metadata, storeFingerprintForResuming: false, removeFingerprintOnSuccess: true, onProgress, onSuccess (extracts URL from upload.url), onError })`
         - Returns the upload instance (caller calls `.start()`)
       - Export `isTusSupported(): boolean` that checks `tus.isSupported`

    IMPORTANT: Do NOT create React hooks in this task. These are pure library modules with no React dependency. The hook is created in Plan 02.
  </action>
  <verify>
    - `cd frontend && bun run tsc --noEmit` passes (TypeScript compilation)
    - All three files exist and have correct exports
    - No React imports in any of the three files
  </verify>
  <done>
    tus-js-client installed, constants/tusUpload/uploadMetrics modules exist with correct types and exports, TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Vite proxy and backend taskId metadata support</name>
  <files>
    frontend/vite.config.ts
    app/services/upload_session_service.py
  </files>
  <action>
    1. Add `/uploads` proxy entry to `frontend/vite.config.ts`:
       - Add after the existing `/upload` entry:
         ```typescript
         // TUS chunked upload endpoint (tuspyserver)
         '/uploads': {
           target: apiUrl,
           changeOrigin: true,
         },
         ```
       - Note: `/upload` (singular, existing) and `/uploads` (plural, TUS) are different routes

    2. Modify `app/services/upload_session_service.py` to use client-provided taskId:
       - In `start_transcription()`, after magic bytes validation and audio loading, before creating DomainTask:
       - Read taskId from metadata: `task_id = metadata.get("taskId") or str(uuid4())`
       - Use this `task_id` as the `uuid` parameter when creating `DomainTask`:
         ```python
         task_id = metadata.get("taskId") or str(uuid4())
         task = DomainTask(
             uuid=task_id,
             ...
         )
         ```
       - This is a ~2 line change. The fallback to `uuid4()` ensures backward compatibility if no taskId is provided.
       - Keep the `from uuid import uuid4` import (used as fallback)

    WHY this matters: The TUS protocol returns 204 No Content on upload completion. The frontend cannot extract a task ID from the response. By pre-generating the task ID on the frontend and sending it as TUS metadata, the frontend already knows the task ID before upload starts and can subscribe to WebSocket immediately after upload completes. This eliminates polling, extra endpoints, and timing issues.
  </action>
  <verify>
    - `cd frontend && bun run tsc --noEmit` passes
    - `grep -n "taskId" app/services/upload_session_service.py` shows the metadata.get line
    - `grep -n "'/uploads'" frontend/vite.config.ts` shows the proxy entry
  </verify>
  <done>
    Vite proxy forwards /uploads to backend in dev. Backend reads optional taskId from TUS metadata, falling back to uuid4() for backward compatibility.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && bun run tsc --noEmit` - TypeScript compiles with new modules
2. `cd frontend && bun run build` - Production build succeeds
3. Verify tus-js-client in frontend/package.json dependencies
4. Verify all three lib/upload/ modules export expected functions/classes
5. Verify backend still works with existing direct upload (backward compatible)
</verification>

<success_criteria>
- tus-js-client is in package.json and importable
- Three lib/upload/ modules exist with typed exports
- Vite proxy has /uploads entry
- Backend upload_session_service.py reads taskId from metadata with uuid4() fallback
- TypeScript and build both pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-frontend-chunking/08-01-SUMMARY.md`
</output>
