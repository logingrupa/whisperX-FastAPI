---
phase: 08-frontend-chunking
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/hooks/useTusUpload.ts
  - frontend/src/hooks/useUploadOrchestration.ts
  - frontend/src/types/upload.ts
autonomous: true

must_haves:
  truths:
    - "Files >= 80MB are uploaded via TUS chunked protocol"
    - "Files < 80MB continue using existing direct upload flow unchanged"
    - "TUS upload generates taskId before upload starts and sends it as metadata"
    - "After TUS upload completes, WebSocket subscribes using the pre-generated taskId"
    - "Upload routing is invisible to the user"
  artifacts:
    - path: "frontend/src/hooks/useTusUpload.ts"
      provides: "React hook wrapping TUS upload with progress state"
    - path: "frontend/src/hooks/useUploadOrchestration.ts"
      provides: "File size routing: direct vs TUS path"
    - path: "frontend/src/types/upload.ts"
      provides: "Extended FileQueueItem with upload speed/ETA fields"
  key_links:
    - from: "frontend/src/hooks/useTusUpload.ts"
      to: "frontend/src/lib/upload/tusUpload.ts"
      via: "createTusUpload import"
      pattern: "createTusUpload"
    - from: "frontend/src/hooks/useTusUpload.ts"
      to: "frontend/src/lib/upload/uploadMetrics.ts"
      via: "UploadSpeedTracker import"
      pattern: "UploadSpeedTracker"
    - from: "frontend/src/hooks/useUploadOrchestration.ts"
      to: "frontend/src/lib/upload/constants.ts"
      via: "SIZE_THRESHOLD import"
      pattern: "SIZE_THRESHOLD"
    - from: "frontend/src/hooks/useUploadOrchestration.ts"
      to: "frontend/src/hooks/useTusUpload.ts"
      via: "processViaTus function"
      pattern: "processViaTus"
---

<objective>
Wire TUS upload into the orchestration flow with file size routing and taskId handoff.

Purpose: This is the core integration plan -- it connects the library modules from Plan 01 to the existing upload orchestration, adding the size-based routing decision and TUS upload path alongside the existing direct upload path.
Output: useTusUpload hook, modified useUploadOrchestration with dual-path routing, extended types.
</objective>

<execution_context>
@C:\Users\rolan\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rolan\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-frontend-chunking/08-RESEARCH.md
@.planning/phases/08-frontend-chunking/08-CONTEXT.md
@.planning/phases/08-frontend-chunking/08-01-SUMMARY.md

Key existing files:
@frontend/src/hooks/useUploadOrchestration.ts
@frontend/src/types/upload.ts
@frontend/src/lib/api/transcriptionApi.ts
@frontend/src/hooks/useTaskProgress.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend upload types and create useTusUpload hook</name>
  <files>
    frontend/src/types/upload.ts
    frontend/src/hooks/useTusUpload.ts
  </files>
  <action>
    1. Extend `frontend/src/types/upload.ts`:
       - Add optional fields to `FileQueueItem` interface:
         ```typescript
         /** Upload speed formatted (e.g., "12.3 MB/s") -- set during upload phase */
         uploadSpeed?: string;
         /** Estimated time remaining formatted (e.g., "2m 15s") -- set during upload phase */
         uploadEta?: string;
         ```
       - These fields are used by both TUS and (future) direct upload paths

    2. Create `frontend/src/hooks/useTusUpload.ts`:
       - Import `createTusUpload` from `@/lib/upload/tusUpload`
       - Import `UploadSpeedTracker` from `@/lib/upload/uploadMetrics`
       - Import `isTusSupported` from `@/lib/upload/tusUpload`
       - Re-export `isTusSupported` for consumer convenience

       - Export function `useTusUpload()`:
         - No state -- this is a stateless utility hook that returns a function
         - Returns `{ startTusUpload }` where:

         ```typescript
         startTusUpload(
           file: File,
           metadata: Record<string, string>,
           callbacks: {
             onProgress: (percentage: number, speed: string, eta: string) => void;
             onSuccess: (taskId: string) => void;
             onError: (error: string) => void;
           }
         ): { abort: () => void }
         ```

         - Inside `startTusUpload`:
           a. Create `UploadSpeedTracker` instance
           b. Call `createTusUpload(file, metadata, { onProgress, onSuccess, onError })`
           c. In onProgress callback: call `speedTracker.update(bytesSent, bytesTotal)`, then call `callbacks.onProgress(metrics.percentage, metrics.speedFormatted, metrics.etaFormatted)`
           d. In onSuccess callback: extract taskId from metadata (it was pre-generated by caller) and call `callbacks.onSuccess(taskId)`
           e. In onError callback: call `callbacks.onError(error.message)`
           f. Call `upload.start()` to begin the upload
           g. Return `{ abort: () => upload.abort(true) }`

       IMPORTANT: The taskId is NOT extracted from the TUS URL. It is the same UUID the caller generated and passed in metadata. The hook simply passes it through on success. This avoids any race condition with the backend.
  </action>
  <verify>
    - `cd frontend && bun run tsc --noEmit` passes
    - `useTusUpload.ts` imports from lib/upload/ modules (not directly from tus-js-client)
    - No direct tus-js-client import in the hook (abstracted via tusUpload.ts)
  </verify>
  <done>
    FileQueueItem extended with uploadSpeed/uploadEta. useTusUpload hook returns startTusUpload function that wraps TUS library with progress tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add file size routing to useUploadOrchestration</name>
  <files>
    frontend/src/hooks/useUploadOrchestration.ts
  </files>
  <action>
    Modify `useUploadOrchestration.ts` to route files by size to either the existing direct upload or the new TUS upload path. This is the core routing logic.

    1. Add imports at the top:
       ```typescript
       import { SIZE_THRESHOLD } from '@/lib/upload/constants';
       import { useTusUpload, isTusSupported } from '@/hooks/useTusUpload';
       ```

    2. Inside `useUploadOrchestration()`, call `useTusUpload()` to get `startTusUpload`:
       ```typescript
       const { startTusUpload } = useTusUpload();
       ```

    3. Also add a new `updateFileUploadMetrics` function (or extend existing `updateFileProgress`). The file queue needs a way to update speed/eta fields. Two options:
       - Option A: Add a new function in useFileQueue that updates speed/eta fields
       - Option B: Store speed/eta in a separate ref within orchestration and pass them down

       Prefer Option A for SRP: add to `useFileQueue.ts` a new `updateFileUploadMetrics(id: string, speed: string, eta: string)` method that updates the queue item. Export it from `UseFileQueueReturn`.

    4. Create `processViaTus` function (alongside existing `processFile`):
       ```typescript
       const processViaTus = useCallback(async (item: FileQueueItem) => {
         currentFileIdRef.current = item.id;
         updateFileStatus(item.id, 'uploading');
         updateFileProgress(item.id, 0, 'uploading');

         // Pre-generate task ID for WebSocket subscription
         const taskId = crypto.randomUUID();

         const metadata: Record<string, string> = {
           filename: item.file.name,
           filetype: item.file.type || 'application/octet-stream',
           language: item.selectedLanguage || 'auto',
           taskId: taskId,
         };

         startTusUpload(item.file, metadata, {
           onProgress: (percentage, speed, eta) => {
             updateFileProgress(item.id, percentage, 'uploading');
             updateFileUploadMetrics(item.id, speed, eta);
           },
           onSuccess: (returnedTaskId) => {
             // Store task ID and transition to processing
             setFileTaskId(item.id, returnedTaskId);
             currentTaskIdRef.current = returnedTaskId;
             updateFileStatus(item.id, 'processing');
             updateFileProgress(item.id, 100, 'uploading');
           },
           onError: (errorMessage) => {
             setFileError(item.id, 'Upload failed', errorMessage);
             currentFileIdRef.current = null;
             currentTaskIdRef.current = null;
           },
         });
       }, [startTusUpload, updateFileStatus, updateFileProgress, updateFileUploadMetrics, setFileTaskId, setFileError]);
       ```

    5. Modify existing `processFile` to route by size:
       ```typescript
       const processFile = useCallback(async (item: FileQueueItem) => {
         if (!isFileReady(item)) {
           console.warn('File not ready:', item.id);
           return;
         }

         // Route: large files via TUS, small files via direct upload
         if (item.file.size >= SIZE_THRESHOLD && isTusSupported()) {
           processViaTus(item);
           return;
         }

         // Existing direct upload flow (unchanged)
         currentFileIdRef.current = item.id;
         updateFileStatus(item.id, 'uploading');
         // ... rest of existing direct upload code ...
       }, [isFileReady, processViaTus, /* existing deps */]);
       ```

    6. The existing direct upload code in processFile remains UNCHANGED. Only the routing decision is added at the top.

    CRITICAL: The `processViaTus` flow is intentionally different from direct upload:
    - Direct: `await startTranscription()` returns taskId synchronously
    - TUS: taskId is pre-generated, upload is async with callbacks, WebSocket subscribes after onSuccess

    The existing `handleStartFile`, `handleStartAll`, `handleRetry`, and auto-process effect all work unchanged because they call `processFile` which now routes internally.
  </action>
  <verify>
    - `cd frontend && bun run tsc --noEmit` passes
    - `grep -n "SIZE_THRESHOLD" frontend/src/hooks/useUploadOrchestration.ts` shows the routing check
    - `grep -n "processViaTus" frontend/src/hooks/useUploadOrchestration.ts` shows the TUS path
    - `grep -n "crypto.randomUUID" frontend/src/hooks/useUploadOrchestration.ts` shows taskId pre-generation
    - Existing direct upload code within processFile is preserved (not deleted/rewritten)
  </verify>
  <done>
    Files >= 80MB route to TUS upload via processViaTus. Files < 80MB use existing direct upload. Routing is transparent to all callers (handleStartFile, handleStartAll, handleRetry). TaskId is pre-generated and sent as TUS metadata.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && bun run tsc --noEmit` - TypeScript compiles cleanly
2. `cd frontend && bun run build` - Production build succeeds
3. Trace the TUS upload flow: processFile -> SIZE_THRESHOLD check -> processViaTus -> startTusUpload -> createTusUpload -> tus.Upload.start()
4. Trace the taskId flow: crypto.randomUUID() -> metadata.taskId -> backend reads metadata.get("taskId") -> DomainTask(uuid=taskId)
5. Verify existing direct upload flow is unchanged for files < 80MB
</verification>

<success_criteria>
- Files >= 80MB are routed to processViaTus (TUS upload path)
- Files < 80MB use the existing processFile direct upload path (unchanged)
- taskId is pre-generated and flows through TUS metadata to backend
- All existing functionality (start, retry, auto-process) works for both paths
- TypeScript compiles and build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/08-frontend-chunking/08-02-SUMMARY.md`
</output>
